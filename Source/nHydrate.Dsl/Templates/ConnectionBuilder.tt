<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#@ include file="PathMerge.tt" #>
<#@ include file="Utilities.tt" #>
<#@ include file="Merge.tt" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace <#= this.DslLibrary.Namespace #>
{
<#
		this.GenerateConnectionBuilders(this.DslLibrary);
		if(this.IsDsl && this.Dsl.Editor != null)
		{
			this.GenerateConnectActions(this.Dsl.Editor);
		}
#>
}

<#+
// Simple class to store consolidated role player information
private class RolePlayerConnectPair
{
	public RolePlayerConnectPair ( RolePlayerConnectDirective source, RolePlayerConnectDirective target)
	{
		this.Source = source;
		this.Target = target;
	}
	
	public RolePlayerConnectDirective Source;
	public RolePlayerConnectDirective Target;
}

// Simple class to store consolidated path method traversal
private class PathTraversalPair
{
	public PathTraversalPair ( DomainPath path, string methodName)
	{
		this.Path = path;
		this.MethodName = methodName;
		this.NeedsGeneration = false;
	}
	
	public DomainPath Path;
	public string MethodName;
	public bool NeedsGeneration;
}

private void PopulateRolePlayerMap( Dictionary<DomainClass, bool> map,
                                    ICollection<RolePlayerConnectDirective> directives )
{
	foreach ( RolePlayerConnectDirective directive in directives )
	{
		bool flag;
		if ( !map.TryGetValue( directive.AcceptingClass, out flag ) )
		{
			map[directive.AcceptingClass] = directive.UsesRoleSpecificCustomAccept;
		}
		else
		{
			map[directive.AcceptingClass] |= directive.UsesRoleSpecificCustomAccept;
		}
	}
}

/// <summary>
/// Generate the ConnectionBuilders specified in a library
/// </summary>
public void GenerateConnectionBuilders(DslLibrary library)
{

	DomainClass rootClass = (this.IsDsl && this.Dsl.Editor != null) ? this.Dsl.Editor.RootClass : null;
	
	foreach (ConnectionBuilder builder in library.ConnectionBuilders)
	{
		if (builder.IsCustom)
		{
#>
	/// <summary>
	/// Empty ConnectionBuilder class as a placeholder for custom code.
	/// </summary>
	<#= rootClass != null ? CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) : this.IsDsl ? "internal" : "public" #> static partial class <#= builder.Name #>
	{
	}
<#+
		}
		else // Not custom - create a double-derived builder class.
		{
			// Data preparation
			// Collate full set of source and target role players
			// First create maps that aggregate the custom accept flags as a custom flag marked anywhere against a source causes 
			// it to be custom tested in all cases. 
			
			Dictionary<DomainClass, bool> sourceAcceptMap = new Dictionary<DomainClass, bool>();
			Dictionary<DomainClass, bool> targetAcceptMap = new Dictionary<DomainClass, bool>();
			
			foreach ( LinkConnectDirective lcDirective in builder.LinkConnectDirectives )
			{
				PopulateRolePlayerMap(sourceAcceptMap, lcDirective.SourceDirectives);
				PopulateRolePlayerMap(targetAcceptMap, lcDirective.TargetDirectives);
			}

			// Now set up ordered collections of sources with ordered collections of targets within them to make traversal
			// simple. The targets collections will contain back pointers to the pair of role player records that generated them.
			Dictionary<DomainClass, Dictionary<DomainClass, RolePlayerConnectPair>> rolePlayerMap = new Dictionary<DomainClass, Dictionary<DomainClass, RolePlayerConnectPair>>();
			List<DomainClass> sortedTargetKeys = new List<DomainClass>();
			
			// Maps string representations of paths (which are comparable) to domain path/traversal method name pairs
			Dictionary<string, PathTraversalPair> traversalMethods = new Dictionary<string, PathTraversalPair>();
			int methodId = 1;
			foreach ( LinkConnectDirective lcDirective in builder.LinkConnectDirectives )
			{
				foreach (RolePlayerConnectDirective sourceDirective in lcDirective.SourceDirectives)
				{
					Dictionary<DomainClass, RolePlayerConnectPair> inner;
					if (!rolePlayerMap.TryGetValue(sourceDirective.AcceptingClass, out inner))
					{
						inner = new Dictionary<DomainClass, RolePlayerConnectPair>();
						rolePlayerMap[sourceDirective.AcceptingClass] = inner;
					}
					foreach (RolePlayerConnectDirective targetDirective in lcDirective.TargetDirectives)
					{
						RolePlayerConnectPair pair;
						if (!inner.TryGetValue(targetDirective.AcceptingClass, out pair))
						{
							pair = new RolePlayerConnectPair(sourceDirective, targetDirective);
							inner[targetDirective.AcceptingClass] = pair;
						}
						else
						{
							// Validation should catch this eventually
							this.Error("Duplicate source, target role player pairing for ConnectionBuilder");
							return;
						}
					}
					
					if(sourceDirective.PathToRolePlayer != null)
					{
						DomainPath path = sourceDirective.PathToRolePlayer;
						string pathString = path.ToString();
						if(!traversalMethods.ContainsKey(pathString))
						{
							DomainClass inputType=path.Segments[0].Role.RolePlayer;
							DomainClass outputType=path.Segments[path.Segments.Count-1].Role.RolePlayer;
							traversalMethods[pathString] = new PathTraversalPair(path, "NavigateFrom" + inputType.Name.Replace('@','_') + "To" + outputType.Name.Replace('@','_') + methodId++);
						}
					}
				}
				foreach (RolePlayerConnectDirective targetDirective in lcDirective.TargetDirectives)
				{
					sortedTargetKeys.Add(targetDirective.AcceptingClass);
					
					if(targetDirective.PathToRolePlayer != null)
					{
						DomainPath path = targetDirective.PathToRolePlayer;
						string pathString = path.ToString();
						if(!traversalMethods.ContainsKey(pathString))
						{
							DomainClass inputType=path.Segments[0].Role.RolePlayer;
							DomainClass outputType=path.Segments[path.Segments.Count-1].Role.RolePlayer;
							traversalMethods[pathString] = new PathTraversalPair(path, "NavigateFrom" + inputType.Name.Replace('@','_') + "To" + outputType.Name.Replace('@','_') + methodId++);
						}
					}
				}
			}
			List<DomainClass> sortedSourceKeys = new List<DomainClass>(rolePlayerMap.Keys);
			sortedSourceKeys.Sort(new DomainClassInheritanceComparer());
			sortedTargetKeys.Sort(new DomainClassInheritanceComparer());
#>
	/// <summary>
	/// ConnectionBuilder class to provide logic for constructing connections between elements.
	/// </summary>
	<#= rootClass != null ? CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) : this.IsDsl ? "internal" : "public" #> static partial class <#= builder.Name #>
	{
		#region Accept Connection Methods
		/// <summary>
		/// Test whether a given model element is acceptable to this ConnectionBuilder as the source of a connection.
		/// </summary>
		/// <param name="candidate">The model element to test.</param>
		/// <returns>Whether the element can be used as the source of a connection.</returns>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		public static bool CanAcceptSource(DslModeling::ModelElement candidate)
		{
			if (candidate == null) return false;
<#+
			foreach (DomainClass source in sortedSourceKeys)
			{
#>
			else if (candidate is <#= source.GetFullName(true) #>)
			{ 
<#+
				if (sourceAcceptMap[source])
				{
#>
				// Add a custom method to your code with the following signature:
				// private static bool CanAccept<#= source.Name #>AsSource(<#= source.Name #> candidate)
				// {
				// }
				return CanAccept<#= source.Name #>AsSource((<#= source.GetFullName(true) #>)candidate);
<#+
				}
				else
				{
#>
				return true;
<#+
				}
#>
			}
<#+
			}
#>
			else
				return false;
		}

		/// <summary>
		/// Test whether a given model element is acceptable to this ConnectionBuilder as the target of a connection.
		/// </summary>
		/// <param name="candidate">The model element to test.</param>
		/// <returns>Whether the element can be used as the target of a connection.</returns>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		public static bool CanAcceptTarget(DslModeling::ModelElement candidate)
		{
			if (candidate == null) return false;
<#+
			foreach (DomainClass target in sortedTargetKeys)
			{
#>
			else if (candidate is <#= target.GetFullName(true) #>)
			{ 
<#+
				if (targetAcceptMap[target])
				{
#>
				// Add a custom method to your code with the following signature:
				// private static bool CanAccept<#= target.Name #>AsTarget(<#= target.Name #> candidate)
				// {
				// }
				return CanAccept<#= target.Name #>AsTarget((<#= target.GetFullName(true) #>)candidate);
<#+
				}
				else
				{
#>
				return true;
<#+
				}
#>
			}
<#+
			}
#>
			else
				return false;
		}
		
		/// <summary>
		/// Test whether a given pair of model elements are acceptable to this ConnectionBuilder as the source and target of a connection
		/// </summary>
		/// <param name="candidateSource">The model element to test as a source</param>
		/// <param name="candidateTarget">The model element to test as a target</param>
		/// <returns>Whether the elements can be used as the source and target of a connection</returns>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		public static bool CanAcceptSourceAndTarget(DslModeling::ModelElement candidateSource, DslModeling::ModelElement candidateTarget)
		{
			// Accepts null, null; source, null; source, target but NOT null, target
			if (candidateSource == null)
			{
				if (candidateTarget != null)
				{
					throw new global::System.ArgumentNullException("candidateSource");
				}
				else // Both null
				{
					return false;
				}
			}
			bool acceptSource = CanAcceptSource(candidateSource);
			// If the source wasn't accepted then there's no point checking targets.
			// If there is no target then the source controls the accept.
			if (!acceptSource || candidateTarget == null)
			{
				return acceptSource;
			}
			else // Check combinations
			{
<#+
			foreach (DomainClass source in sortedSourceKeys)
			{
#>
				if (candidateSource is <#= source.GetFullName(true) #>)
				{
<#+
				List<DomainClass> matchingTargets = new List<DomainClass>(rolePlayerMap[source].Keys);
				matchingTargets.Sort(new DomainClassInheritanceComparer());
				foreach (DomainClass target in matchingTargets)
				{
					RolePlayerConnectPair pair = rolePlayerMap[source][target];
					
					bool sourceRestricted = false, targetRestricted = false, relationshipRestricted = false;
					DomainRole sourceRole = null, targetRole = null;
					
					string sourceName = "source" + source.Name.Replace('@','_');
					string targetName = "target" + target.Name.Replace('@','_');
					bool needCastToSource, needCastToTarget;
					needCastToSource = needCastToTarget = (targetAcceptMap[target] || sourceAcceptMap[source]);
					
					DomainRelationship relationship = pair.Target.TargetOf.DomainRelationship; // assume source and target point to the same relationship, so using pair.Target is equivalent to using pair.Source
					if(relationship != null)
					{
						sourceRole = relationship.Source;
						targetRole = relationship.Target;
						
						sourceRestricted = targetRole.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One || targetRole.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne;
						targetRestricted = sourceRole.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One || sourceRole.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne;
						relationshipRestricted = !relationship.AllowsDuplicates;
						needCastToSource = needCastToSource || sourceRestricted || relationshipRestricted;
						needCastToTarget = needCastToTarget || targetRestricted || relationshipRestricted;
					}
#>
					<#= target.Equals(matchingTargets[0]) ? "" : "else " #>if (candidateTarget is <#= target.GetFullName(true) #>)
					{
<#+
					if(needCastToSource)
					{
#>
						<#= source.GetFullName(true) #> <#= sourceName #> = (<#= source.GetFullName(true) #>)candidateSource;
<#+
					}
					if(needCastToTarget)
					{
#>
						<#= target.GetFullName(true) #> <#= targetName #> = (<#= target.GetFullName(true) #>)candidateTarget;
<#+
					}
					if (targetAcceptMap[target] || sourceAcceptMap[source])
					{
#>
						// Add a custom method to your code with the following signature:
						// private static bool CanAccept<#= source.Name #>And<#= target.Name #>AsSourceAndTarget(<#= source.Name #> <#= sourceName #>, <#= target.Name #> <#= targetName #>)
						// {
						// }
						if(!CanAccept<#= source.Name #>And<#= target.Name #>AsSourceAndTarget(<#= sourceName #>, <#= targetName #>)) return false;
<#+
					}
					if(relationshipRestricted || sourceRestricted || targetRestricted)
					{
						if ((sourceRestricted || relationshipRestricted) && pair.Source.PathToRolePlayer != null)
						{
							DomainPath path = pair.Source.PathToRolePlayer;
							PathTraversalPair pathPair = traversalMethods[path.ToString()];
							DomainClass sourceOutputType=path.Segments[path.Segments.Count-1].Role.RolePlayer;
							this.WriteLine("\t\t\t\t\t\t// Traverse source path");
#>
						<#= sourceOutputType.GetFullName(true) #> source<#= sourceOutputType.Name.Replace('@','_') #> = <#= pathPair.MethodName #>(<#= sourceName #>);
<#+
							sourceName = "source" + sourceOutputType.Name.Replace('@','_');
							pathPair.NeedsGeneration = true;
						}
						
						if ((targetRestricted || relationshipRestricted) && pair.Target.PathToRolePlayer != null)
						{
							DomainPath path = pair.Target.PathToRolePlayer;
							PathTraversalPair pathPair = traversalMethods[path.ToString()];
							DomainClass targetOutputType=path.Segments[path.Segments.Count-1].Role.RolePlayer;
							this.WriteLine("\t\t\t\t\t\t// Traverse target path");
#>
						<#= CodeGenerationUtilities.GetSegmentOutputType(path.Segments[path.Segments.Count-1]) #> target<#= targetOutputType.Name.Replace('@','_') #> = <#= pathPair.MethodName #>(<#= targetName #>);
<#+
							targetName = "target" + targetOutputType.Name.Replace('@','_');
							pathPair.NeedsGeneration = true;
						}
					}
					
					if(sourceRestricted)
					{
#>
						if(<#= targetName #> == null || <#= relationship.GetFullName(true) #>.GetLinkTo<#= targetRole.PropertyName.TrimStart('@') #>(<#= targetName #>) != null) return false;
<#+
					}
					if(targetRestricted)
					{
#>
						if(<#= sourceName #> == null || <#= relationship.GetFullName(true) #>.GetLinkTo<#= sourceRole.PropertyName.TrimStart('@') #>(<#= sourceName #>) != null) return false;
<#+
					}
					if(relationshipRestricted)
					{
#>
						if(<#= targetName #> == null || <#= sourceName #> == null || <#= relationship.GetFullName(true) #>.GetLinks(<#= sourceName #>, <#= targetName #>).Count > 0) return false;
<#+
					}
#>
						return true;
					}
<#+
				}
#>
				}
<#+
			}
#>				
			}
			return false;
		}
		#endregion

		#region Connection Methods
		/// <summary>
		/// Make a connection between the given pair of source and target elements
		/// </summary>
		/// <param name="source">The model element to use as the source of the connection</param>
		/// <param name="target">The model element to use as the target of the connection</param>
		/// <returns>A link representing the created connection</returns>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		public static DslModeling::ElementLink Connect(DslModeling::ModelElement source, DslModeling::ModelElement target)
		{
			if (source == null)
			{
				throw new global::System.ArgumentNullException("source");
			}
			if (target == null)
			{
				throw new global::System.ArgumentNullException("target");
			}
			
			if (CanAcceptSourceAndTarget(source, target))
			{
<#+
			foreach (DomainClass source in sortedSourceKeys)
			{
#>
				if (source is <#= source.GetFullName(true) #>)
				{
<#+
				List<DomainClass> matchingTargets = new List<DomainClass>(rolePlayerMap[source].Keys);
				matchingTargets.Sort(new DomainClassInheritanceComparer());
				
				bool first = true;
				foreach (DomainClass target in matchingTargets)
				{
					RolePlayerConnectPair pair = rolePlayerMap[source][target];
#>
					<#= first ? "" : "else " #>if (target is <#= target.GetFullName(true) #>)
					{
<#+
					if ( !pair.Target.TargetOf.UsesCustomConnect)
					{
#>
						<#= source.GetFullName(true) #> sourceAccepted = (<#= source.GetFullName(true) #>)source;
						<#= target.GetFullName(true) #> targetAccepted = (<#= target.GetFullName(true) #>)target;
<#+
					}

					// Default names to typed versions of parameters if there are no paths to traverse
					string sourceName = "sourceAccepted";
					string targetName = "targetAccepted";

					string traversedSourceParameter=string.Empty;
					string traversedTargetParameter=string.Empty;
					
					// The types obtained by traversing any supplied paths
					DomainClass traversedSourceParameterType=null;
					DomainClass traversedTargetParameterType=null;
					
					string traversedSourceParameterDeclaration=string.Empty;
					string traversedTargetParameterDeclaration=string.Empty;
					
					if ( pair.Source.PathToRolePlayer != null && !pair.Target.TargetOf.UsesCustomConnect)
					{
						traversedSourceParameterType=pair.Source.PathToRolePlayer.Segments[pair.Source.PathToRolePlayer.Segments.Count-1].Role.RolePlayer;
						sourceName="source" + traversedSourceParameterType.Name.Replace('@','_');
						traversedSourceParameter=", " + sourceName;
						traversedSourceParameterDeclaration=", " + traversedSourceParameterType.GetFullName(true) + " sourceAfterPathTraverse";

						this.WriteLine("\t\t\t\t\t\t// Traverse source path");
						DomainPath path = pair.Source.PathToRolePlayer;
						PathTraversalPair pathPair = traversalMethods[path.ToString()];
						pathPair.NeedsGeneration = true;
#>
						<#= traversedSourceParameterType.GetFullName(true) #> <#= sourceName #> = <#= pathPair.MethodName #>(sourceAccepted);
<#+
					}
					if ( pair.Target.PathToRolePlayer != null && !pair.Target.TargetOf.UsesCustomConnect)
					{
						traversedTargetParameterType=pair.Target.PathToRolePlayer.Segments[pair.Target.PathToRolePlayer.Segments.Count-1].Role.RolePlayer;
						targetName="target" + traversedTargetParameterType.Name.Replace('@','_');
						traversedTargetParameter=", " + targetName;
						traversedTargetParameterDeclaration=", " + traversedTargetParameterType.GetFullName(true) + " targetAfterPathTraverse";

						this.WriteLine("\t\t\t\t\t\t// Traverse target path");
						DomainPath path = pair.Target.PathToRolePlayer;
						PathTraversalPair pathPair = traversalMethods[path.ToString()];
						pathPair.NeedsGeneration = true;
#>
						<#= traversedTargetParameterType.GetFullName(true) #> <#= targetName #> = <#= pathPair.MethodName #>(targetAccepted);
<#+
					}
					first = false;
					if (pair.Target.TargetOf.UsesCustomConnect)
					{
						// This is the overriden customization point which 
						// This custom method takes two, three or four parameters, depending whether "PathToRolePlayer" is specified for the givensource or target role player directive
						// The pre-path traversal elements are always specified and the post-traversal elements are specified if a path was present.
#>
						// Add a custom method to your code with the following signature:
						// private static ElementLink ConnectSourceToTarget(ModelElement source, ModelElement target)
						// {
						// }
						return ConnectSourceToTarget(source, target);
<#+
					}
					else if (pair.Target.UsesRoleSpecificCustomConnect ||
					    pair.Source.UsesRoleSpecificCustomConnect)
					{
						// This custom method takes two, three or four parameters, depending whether "PathToRolePlayer" is specified for the givensource or target role player directive
						// The pre-path traversal elements are always specified and the post-traversal elements are specified if a path was present.
#>
						// Add a custom method to your code with the following signature:
						// private static ElementLink Connect<#= source.Name #>To<#= target.Name #>(<#= source.GetFullName(true) #> sourceBeforePathTraverse<#= traversedSourceParameterDeclaration #>, <#= target.GetFullName(true) #> targetBeforePathTraverse<#= traversedTargetParameterDeclaration #>)
						// {
						// }
						return Connect<#= source.Name #>To<#= target.Name #>(sourceAccepted <#= traversedSourceParameter #>, targetAccepted<#= traversedTargetParameter #>);
<#+
					}
					else
					{
						// The path may not have taken us to the correct type for the relationship's role players.
						// It's a runtime error if the path endpoint can't be cast to the Rel roleplayer
						
						// The types of the role players of the Relationship to be created
						DomainClass sourceRolePlayerType=pair.Target.TargetOf.DomainRelationship.Source.RolePlayer;
						DomainClass targetRolePlayerType=pair.Target.TargetOf.DomainRelationship.Target.RolePlayer;
					
						if (traversedSourceParameterType != null && !sourceRolePlayerType.Equals(traversedSourceParameterType))
						{
#>

						<#= sourceRolePlayerType.GetFullName(true) #> sourceRolePlayer = <#= sourceName #> as <#= sourceRolePlayerType.GetFullName(true) #>;
						if ( sourceRolePlayer == null ) throw new global::System.InvalidOperationException("DomainPath traversal returns incorrect source type: expected '<#= sourceRolePlayerType.GetFullName(false) #>, actual '<#= traversedSourceParameterType.GetFullName(false) #>'.");
<#+
							sourceName = "sourceRolePlayer";
						}
						if (traversedTargetParameterType != null && !targetRolePlayerType.Equals(traversedTargetParameterType))
						{
#>

						<#= targetRolePlayerType.GetFullName(true) #> targetRolePlayer = <#= targetName #> as <#= targetRolePlayerType.GetFullName(true) #>;
						if ( targetRolePlayer == null ) throw new global::System.InvalidOperationException("DomainPath traversal returns incorrect target type: expected '<#= targetRolePlayerType.GetFullName(false) #>, actual '<#= traversedTargetParameterType.GetFullName(false) #>'.");
<#+
							targetName = "targetRolePlayer";
						}
						
#>
						DslModeling::ElementLink result = new <#= pair.Target.TargetOf.DomainRelationship.GetFullName(true) #>(<#= sourceName #>, <#= targetName #>);
						if (DslModeling::DomainClassInfo.HasNameProperty(result))
						{
							DslModeling::DomainClassInfo.SetUniqueName(result);
						}
						return result;
<#+
					}
#>
					}
<#+
				}
#>
				}
<#+
			}
#>				
			}
			global::System.Diagnostics.Debug.Fail("Having agreed that the connection can be accepted we should never fail to make one.");
			throw new global::System.InvalidOperationException();
		}
		#endregion
<#+
			if(traversalMethods.Count > 0)
			{
#>
		#region Path traversal helper methods
<#+
				foreach (PathTraversalPair pair in traversalMethods.Values)
				{
					if(pair.NeedsGeneration)
					{
						GeneratePathMethod(pair.Path, pair.MethodName, "private");
					}
				}
#>
		#endregion
<#+
			}
#>
 	}
<#+
		} // else(IsCustom)
	} // foreach ConnectionBuilder
}
#>

<#+
public void GenerateConnectActions(Editor editor)
{
	Designer designer = CodeGenerationUtilities.GetDesigner(this.DslLibrary);
	bool stickyToolbox = (designer != null ? designer.UsesStickyToolboxItems : false);
	
	foreach(ToolboxTab tab in editor.ToolboxTabs)
	{
		foreach(Tool tool in tab.Tools)
		{
			if (stickyToolbox)
			{
				// Generate code for click-style toolbox item creation.
				ElementTool elementTool = tool as ElementTool;
				if (elementTool != null)
				{
					this.GenerateCreateAction(elementTool);
					continue;
				}
			}
				
			ConnectionTool connectionTool = tool as ConnectionTool;
			if(connectionTool == null || connectionTool.ConnectionBuilder == null) continue;
			ConnectionBuilder builder = connectionTool.ConnectionBuilder;
			string builderTypeName = builder.Name;
			if (builder.DslLibrary != this.DslLibrary)
			{
				if (string.IsNullOrEmpty(builder.DslLibrary.Namespace))
				{
					builderTypeName = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}{1}", "global::", builder.Name);
				}
				else
				{
					builderTypeName = string.Format(System.Globalization.CultureInfo.InvariantCulture, "{0}{1}.{2}", "global::", builder.DslLibrary.Namespace, builder.Name);
				}
			}
#>
 	
 	/// <summary>
	/// Handles interaction between the ConnectionBuilder and the corresponding ConnectionTool.
	/// </summary>
	internal partial class <#= tool.Name #>ConnectAction : DslDiagrams::ConnectAction
	{
		private DslDiagrams::ConnectionType[] connectionTypes;
<#+
			bool customSourceCursor = !String.IsNullOrEmpty(connectionTool.SourceCursorIcon);
			bool customTargetCursor = !String.IsNullOrEmpty(connectionTool.TargetCursorIcon);
			if(customSourceCursor)
			{
#>
		private global::System.Windows.Forms.Cursor sourceCursor;
<#+
			}
			if(customTargetCursor)
			{
#>
		private global::System.Windows.Forms.Cursor targetCursor;
<#+
			}
#>
		
		/// <summary>
		/// Constructs a new <#= tool.Name #>ConnectAction for the given Diagram.
		/// </summary>
		public <#= tool.Name #>ConnectAction(DslDiagrams::Diagram diagram): base(diagram, true) 
		{
<#+
			if(customSourceCursor || customTargetCursor)
			{
#>
			global::System.Resources.ResourceManager resourceManager = <#= this.Dsl.GetFullName(true) #>DomainModel.SingletonResourceManager;
			global::System.Globalization.CultureInfo resourceCulture = global::System.Globalization.CultureInfo.CurrentUICulture;

<#+
				if(customSourceCursor)
				{
#>
			byte[] sourceCursorBytes = (byte[])resourceManager.GetObject("<#= tool.Name #>SourceCursor", resourceCulture);
			using(global::System.IO.MemoryStream sourceCursorStream = new global::System.IO.MemoryStream(sourceCursorBytes))
			{ 
				this.sourceCursor = new global::System.Windows.Forms.Cursor(sourceCursorStream);
			}
<#+
				}
				if(customTargetCursor)
				{
#>
			byte[] targetCursorBytes = (byte[])resourceManager.GetObject("<#= tool.Name #>TargetCursor", resourceCulture);
			using(global::System.IO.MemoryStream targetCursorStream = new global::System.IO.MemoryStream(targetCursorBytes))
			{ 
				this.targetCursor = new global::System.Windows.Forms.Cursor(targetCursorStream);
			}
<#+
				}
			}
#>
		}
		
		/// <summary>
		/// Gets the cursor corresponding to the given mouse position.
		/// </summary>
		/// <remarks>
		/// Changes the cursor to Cursors.No before the first mouse click if the source shape is not valid.
		/// </remarks>
		public override global::System.Windows.Forms.Cursor GetCursor(global::System.Windows.Forms.Cursor currentCursor, DslDiagrams::DiagramClientView diagramClientView, DslDiagrams::PointD mousePosition)
		{
			if (this.MouseDownHitShape == null && currentCursor != global::System.Windows.Forms.Cursors.No)
			{
				DslDiagrams::DiagramHitTestInfo hitTestInfo = new DslDiagrams::DiagramHitTestInfo(diagramClientView);
				this.Diagram.DoHitTest(mousePosition, hitTestInfo);
				DslDiagrams::ShapeElement shape = hitTestInfo.HitDiagramItem.Shape;

				DslDiagrams::ConnectionType connectionType = GetConnectionTypes(shape, null)[0];
				string warningString = string.Empty;
				if (!connectionType.CanCreateConnection(shape, null, ref warningString))
				{
					return global::System.Windows.Forms.Cursors.No;
				}
			}
			return base.GetCursor(currentCursor, diagramClientView, mousePosition);
		}
		
<#+
			if(customSourceCursor || customTargetCursor)
			{
#>
		/// <summary>
		/// Associates custom source and target cursors with the connect action.
		/// </summary>
		protected override global::System.Windows.Forms.Cursor GetCursorFromCursorType(DslDiagrams::ConnectActionCursor connectActionCursor)
		{
<#+
				if(customSourceCursor)
				{
#>
			if(connectActionCursor == DslDiagrams::ConnectActionCursor.Searching)
			{
				return this.sourceCursor;
			}
<#+
				}
				if(customTargetCursor)
				{
#>
			if(connectActionCursor == DslDiagrams::ConnectActionCursor.Allowed)
			{
				return this.targetCursor;
			}
<#+
				}
#>
			return base.GetCursorFromCursorType(connectActionCursor);
		}
		
		/// <summary>
		/// Disposes custom cursor resources.
		/// </summary>
		protected override void Dispose(bool disposing)
		{
			try
			{
				if(disposing)
				{
<#+
				if(customSourceCursor)
				{
#>
					if(this.sourceCursor != null)
					{
						this.sourceCursor.Dispose();
						this.sourceCursor = null;
					}
<#+
				}
				if(customTargetCursor)
				{
#>
					if(this.targetCursor != null)
					{
						this.targetCursor.Dispose();
						this.targetCursor = null;
					}
<#+
				}
#>
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}
<#+
			}
#>
		
		/// <summary>
		/// Returns the <#= tool.Name #>ConnectionType associated with this action.
		/// </summary>
		protected override DslDiagrams::ConnectionType[] GetConnectionTypes(DslDiagrams::ShapeElement sourceShapeElement, DslDiagrams::ShapeElement targetShapeElement)
		{
			if(this.connectionTypes == null)
			{
				this.connectionTypes = new DslDiagrams::ConnectionType[] { new <#= tool.Name #>ConnectionType() };
			}
			
			return this.connectionTypes;
		}
		
		private partial class <#= tool.Name #>ConnectionTypeBase : DslDiagrams::ConnectionType
		{
			/// <summary>
			/// Constructs a new the <#= tool.Name #>ConnectionType with the given ConnectionBuilder.
			/// </summary>
			protected <#= tool.Name #>ConnectionTypeBase() : base() {}
			
			private static DslDiagrams::ShapeElement RemovePassThroughShapes(DslDiagrams::ShapeElement shape)
			{
				if (shape is DslDiagrams::Compartment)
				{
					return shape.ParentShape;
				}
				DslDiagrams::SwimlaneShape swimlane = shape as DslDiagrams::SwimlaneShape;
				if (swimlane != null && swimlane.ForwardDragDropToParent)
				{
					return shape.ParentShape;
				}
				return shape;
			}
						
			/// <summary>
			/// Called by the base ConnectAction class to determine if the given shapes can be connected.
			/// </summary>
			/// <remarks>
			/// This implementation delegates calls to the ConnectionBuilder <#= builder.Name #>.
			/// </remarks>
			public override bool CanCreateConnection(DslDiagrams::ShapeElement sourceShapeElement, DslDiagrams::ShapeElement targetShapeElement, ref string connectionWarning)
			{
				bool canConnect = true;
				
				if(sourceShapeElement == null) throw new global::System.ArgumentNullException("sourceShapeElement");
				sourceShapeElement = RemovePassThroughShapes(sourceShapeElement);
				DslModeling::ModelElement sourceElement = sourceShapeElement.ModelElement;
				if(sourceElement == null) sourceElement = sourceShapeElement;
				
				DslModeling::ModelElement targetElement = null;
				if (targetShapeElement != null)
				{
					targetShapeElement = RemovePassThroughShapes(targetShapeElement);
					targetElement = targetShapeElement.ModelElement;
					if(targetElement == null) targetElement = targetShapeElement;
<#+
			if(connectionTool.ReversesDirection)
			{
#>					
					// The <#= tool.Name #> connection tool specifies that source and target should be reversed.
					// base.CanCreateConnection must be called to check whether existing Locks prevent this link from getting created.
					canConnect = base.CanCreateConnection(targetShapeElement, sourceShapeElement, ref connectionWarning);
<#+
			}
#>			
				}

<#+
			if(!connectionTool.ReversesDirection)
			{
#>
				// base.CanCreateConnection must be called to check whether existing Locks prevent this link from getting created.	
				canConnect = base.CanCreateConnection(sourceShapeElement, targetShapeElement, ref connectionWarning);
<#+
			}
#>
				if (canConnect)
				{				
					if(targetShapeElement == null)
					{
<#+
			if(!connectionTool.ReversesDirection)
			{
				if(builder.IsCustom)
				{
#>
						// You will need to implement a method with the following signature:
						// public static bool CanAcceptSource(DslModeling::ModelElement sourceElement)
						// {
						// }
						// in a partial class of <#= builder.Name #>.
<#+
				}
#>
						return <#= builderTypeName #>.CanAcceptSource(sourceElement);
<#+
			}
			else
			{
				if(builder.IsCustom)
				{
#>
						// You will need to implement a method with the following signature:
						// public static bool CanAcceptTarget(DslModeling::ModelElement sourceElement)
						// {
						// }
						// in a partial class of <#= builder.Name #>.
<#+
				}
#>
						// The <#= tool.Name #> connection tool specifies that source and target should be reversed. 
						return <#= builderTypeName #>.CanAcceptTarget(sourceElement);
<#+
			}
#>
					}
					else
					{				
<#+
			if(builder.IsCustom)
			{
#>
						// You will need to implement a method with the following signature:
						// public static bool CanAcceptSourceAndTarget(DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
						// {
						// }
						// in a partial class of <#= builder.Name #>.
<#+
			}
			if(!connectionTool.ReversesDirection)
			{
#>
						return <#= builderTypeName #>.CanAcceptSourceAndTarget(sourceElement, targetElement);
<#+
			}
			else
			{
#>
						// The <#= tool.Name #> connection tool specifies that source and target should be reversed. 
						return <#= builderTypeName #>.CanAcceptSourceAndTarget(targetElement, sourceElement);
<#+
			}
#>
					}
				}
				else
				{
					//return false
					return canConnect;
				}
			}
						
			/// <summary>
			/// Called by the base ConnectAction class to ask whether the given source and target are valid.
			/// </summary>
			/// <remarks>
			/// Always return true here, to give CanCreateConnection a chance to decide.
			/// </remarks>
			public override bool IsValidSourceAndTarget(DslDiagrams::ShapeElement sourceShapeElement, DslDiagrams::ShapeElement targetShapeElement)
			{
				return true;
			}
			
			/// <summary>
			/// Called by the base ConnectAction class to create the underlying relationship.
			/// </summary>
			/// <remarks>
			/// This implementation delegates calls to the ConnectionBuilder <#= builder.Name #>.
			/// </remarks>
			public override void CreateConnection(DslDiagrams::ShapeElement sourceShapeElement, DslDiagrams::ShapeElement targetShapeElement, DslDiagrams::PaintFeedbackArgs paintFeedbackArgs)
			{
				if(sourceShapeElement == null) throw new global::System.ArgumentNullException("sourceShapeElement");
				if(targetShapeElement == null) throw new global::System.ArgumentNullException("targetShapeElement");
				
				sourceShapeElement = RemovePassThroughShapes(sourceShapeElement);
				targetShapeElement = RemovePassThroughShapes(targetShapeElement);
				
				DslModeling::ModelElement sourceElement = sourceShapeElement.ModelElement;
				if(sourceElement == null) sourceElement = sourceShapeElement;
				DslModeling::ModelElement targetElement = targetShapeElement.ModelElement;
				if(targetElement == null) targetElement = targetShapeElement;
<#+
			if(builder.IsCustom)
			{
#>
				// You will need to implement a method with the following signature:
				// public static void Connect(DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
				// {
				// }
				// in a partial class of <#= builder.Name #>.
<#+
			}
			if(!connectionTool.ReversesDirection)
			{
#>
				<#= builderTypeName #>.Connect(sourceElement, targetElement);
<#+
			}
			else
			{
#>
				// The <#= tool.Name #> connection tool specifies that source and target should be reversed. 
				<#= builderTypeName #>.Connect(targetElement, sourceElement);
<#+
			}
#>
			}
		}
		
		private partial class <#= tool.Name #>ConnectionType : <#= tool.Name #>ConnectionTypeBase
		{
			/// <summary>
			/// Constructs a new the <#= tool.Name #>ConnectionType with the given ConnectionBuilder.
			/// </summary>
			public <#= tool.Name #>ConnectionType() : base() {}
		}
	}
<#+
		} // foreach Tool
	} // foreach ToolboxTab
}

public void GenerateCreateAction(ElementTool elementTool)
{
#>

 	/// <summary>
	/// Handles creation of an element through its ElementTool.
	/// </summary>
	internal partial class <#= elementTool.Name #>CreateAction : DslDiagrams::CreateAction
	{
		/// <summary>
		/// Constructs a new <#= elementTool.Name #>CreateAction for the given Diagram.
		/// </summary>
		public <#= elementTool.Name #>CreateAction(DslDiagrams::Diagram diagram): base(diagram)
		{
		}
	}
<#+
}
#>


