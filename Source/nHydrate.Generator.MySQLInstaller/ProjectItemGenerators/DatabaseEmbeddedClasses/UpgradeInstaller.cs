//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 0168
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Xml;

namespace PROJECTNAMESPACE
{
	/// <summary>
	/// Provides installation functionality for databases
	/// </summary>
	internal class UpgradeInstaller
	{
		#region member variables

		internal static readonly Version _def_Version = new Version(-1, -1, -1, -1, -1);
		private const string UPGRADE_FOLDER = ".Upgrade_Scripts";

		private const string DEFAULT_NAMESPACE = "PROJECTNAMESPACE";
		internal const string MODELKEY = "%MODELKEY%";
		private bool _newInstall = false;
		private Version _previousVersion = null;
		private Version _upgradeToVersion = new Version("UPGRADE_VERSION");
		private string _connectionString = string.Empty;
		private MySql.Data.MySqlClient.MySqlConnection _connection;
		private MySql.Data.MySqlClient.MySqlTransaction _transaction;
		private List<EmbeddedResourceName> _resourceNames = new List<EmbeddedResourceName>();

		#endregion

		private static Version UpgradeToVersion
		{
			get
			{
				var q = new UpgradeInstaller(string.Empty, false);
				return q._upgradeToVersion;
			}
		}

		/// <summary>
		/// Upgrades a database to the newest schema
		/// </summary>
		/// <param name="connectionString">The connection string to the database</param>
		/// <param name="newInstall">Determines if this is a new (create) operation or an upgrade</param>
		/// <param name="transaction">The transaction to use for this action. If null, one will be created.</param>
		public static void UpgradeDatabase(string connectionString, bool newInstall, MySql.Data.MySqlClient.MySqlTransaction transaction)
		{
			try
			{
				var upgradeInstaller = new UpgradeInstaller(connectionString, newInstall);
				upgradeInstaller.Initialize();
				upgradeInstaller.RunUpgrade(transaction);
			}
			catch { throw; }
		}

		#region construct / initialize

		private UpgradeInstaller(string connectionString, bool newInstall)
		{
			_previousVersion = new Version(_def_Version);
			_connectionString = connectionString;
			_newInstall = newInstall;
		}

		private void Initialize()
		{
			var settings = new nHydrateSetting();
			settings.Load(_connectionString);

			//Verify that this is the proper database for this model, if there is a previous key
			if (settings.ModelKey != Guid.Empty)
			{
				if (settings.ModelKey != new Guid(MODELKEY))
				{
					if (System.Windows.Forms.MessageBox.Show("The database being updated was created against a different model. This may cause database versioning issues if you continue.\n\nDo you wish to continue?", "Continue?", System.Windows.Forms.MessageBoxButtons.YesNo, System.Windows.Forms.MessageBoxIcon.Warning) != System.Windows.Forms.DialogResult.Yes)
					{
						return;
					}
				}
			}

			if (settings.dbVersion != string.Empty)
			{
				var versionNumbers = settings.dbVersion.Split('.');
				_previousVersion = new Version();
				_previousVersion.Major = int.Parse(versionNumbers[0]);
				_previousVersion.Minor = int.Parse(versionNumbers[1]);
				_previousVersion.Revision = int.Parse(versionNumbers[2]);
				_previousVersion.Build = int.Parse(versionNumbers[3]);
				if (versionNumbers.Length >= 5)
					_previousVersion.Generated = int.Parse(versionNumbers[4]);
			}
			var assem = Assembly.GetExecutingAssembly();
			var resourceNames = assem.GetManifestResourceNames();
			foreach (string resourceName in resourceNames)
			{
				var ern = new EmbeddedResourceName(resourceName);
				_resourceNames.Add(ern);
			}
		}

		#endregion

		public static string GetUpgradeScript(string connectionString)
		{
			var upgradeInstaller = new UpgradeInstaller(connectionString, false);
			upgradeInstaller.Initialize();
			var sb = new StringBuilder();
			upgradeInstaller.UpgradeFolder1(sb);
			upgradeInstaller.UpgradeFolder2(sb);
			upgradeInstaller.UpgradeFolder3(sb);
			upgradeInstaller.UpgradeFolder4(sb);
			upgradeInstaller.UpgradeFolder5(sb);
			upgradeInstaller.UpgradeFolder6(sb);

			var settings = new nHydrateSetting();
			settings.dbVersion = UpgradeInstaller.UpgradeToVersion.ToString(".");
			settings.LastUpdate = DateTime.Now;
			settings.ModelKey = new Guid(MODELKEY);
			settings.History.Add(new HistoryItem() { Version = UpgradeInstaller.UpgradeToVersion.ToString("."), PublishDate = DateTime.Now });
			var arr = settings.GetVersionUpdateScript();
			sb.AppendLine(arr[0]);
			sb.AppendLine(arr[1]);

			return sb.ToString();
		}

		public static void InstallInternalProcedures(string connectionString)
		{
			var upgradeInstaller = new UpgradeInstaller(connectionString, false);
			upgradeInstaller.Initialize();
			upgradeInstaller.InstallInternalProceduresSub(connectionString);
		}

		private void InstallInternalProceduresSub(string connectionString)
		{
			_connectionString = connectionString;
			_connection = new MySql.Data.MySqlClient.MySqlConnection(_connectionString);
			_connection.Open();
			_transaction = _connection.BeginTransaction();
			this.ReinstallStoredProceduresInternal(null, null);
			_transaction.Commit();
		}

		public static bool NeedsUpdate(string connectionString)
		{
			var settings = new nHydrateSetting();
			settings.Load(connectionString);
			if (!settings.IsLoaded) return true; //Cannot find version so upgrade

			var currentDbVersion = _def_Version;
			if (!string.IsNullOrEmpty(settings.dbVersion))
				currentDbVersion = new Version(settings.dbVersion.Split('.'));
			else
				return true;

			return (currentDbVersion < UpgradeInstaller.UpgradeToVersion);
		}

		private void RunUpgrade(MySql.Data.MySqlClient.MySqlTransaction transaction)
		{
			if (transaction == null)
			{
				_connection = new MySql.Data.MySqlClient.MySqlConnection(_connectionString);
				_connection.Open();
				_transaction = _connection.BeginTransaction();
			}
			else
			{
				_connection = transaction.Connection;
				_transaction = transaction;
			}

			try
			{
				var settings = new nHydrateSetting();
				settings.Load(_connectionString);

				var currentDbVersion = _def_Version;
				if (!string.IsNullOrEmpty(settings.dbVersion))
					currentDbVersion = new Version(settings.dbVersion.Split('.'));

				if (currentDbVersion > _upgradeToVersion)
				{
					System.Windows.Forms.MessageBox.Show("The current database version (" + currentDbVersion.ToString() + ") is greater than the current library (" + _upgradeToVersion.ToString() + "). The upgrade will not proceed.", "Error", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Error);
					return;
				}

				#region 1_UserDefinedInitialization
				this.UpgradeFolder1();
				#endregion

				#region 2_Upgrade Scripts
				this.UpgradeFolder2();
				#endregion

				#region 3_GeneratedTablesAndData
				this.UpgradeFolder3();
				#endregion

				#region 4_UserDefinedPostTablesAndData
				this.UpgradeFolder4();
				#endregion

				#region 5_Programmability
				UpgradeFolder5();
				#endregion

				#region 6_UserDefinedFinalize
				UpgradeFolder6();
				#endregion

				//Do not commit if external transation
				if (transaction == null && _transaction != null)
					_transaction.Commit();

				settings.dbVersion = _upgradeToVersion.ToString(".");
				settings.LastUpdate = DateTime.Now;
				settings.ModelKey = new Guid(MODELKEY);
				settings.History.Add(new HistoryItem() { Version = _upgradeToVersion.ToString("."), PublishDate = DateTime.Now });
				settings.Save(_connectionString);
			}
			catch (Exception ex)
			{
				System.Windows.Forms.MessageBox.Show(ex.Message, "Error!", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Error);
				if (transaction == null)
					_transaction.Rollback();
				throw;
			}
			finally
			{
				_connection.Close();
			}

		}

		private void AppendCleanScript(string script, StringBuilder sb)
		{
			if (string.IsNullOrEmpty(script)) return;
			var lines = script.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);
			foreach (var s in lines)
			{
				if (!s.StartsWith("#MODELID"))
					sb.AppendLine(s);
			}
			sb.AppendLine("GO");
		}

		private void UpgradeFolder1()
		{
			UpgradeFolder1(null);
		}

		private void UpgradeFolder1(StringBuilder sb)
		{
			const string MAIN_FOLDER = "._1_UserDefinedInitialization.";
			const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
			const string NEWDATABASE_FOLDER = MAIN_FOLDER + "NewDatabase";
			const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
			const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

			if (_newInstall) //NEW DATABASE
			{
				var scripts = this.GetResourceNameUnderLocation(NEWDATABASE_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else //VERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

			//RUN ALWAYS
			{
				var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

		}

		private void UpgradeFolder2()
		{
			UpgradeFolder2(null);
		}

		private void UpgradeFolder2(StringBuilder sb)
		{
			const string UPGRADE_GENERATED_FOLDER = "._2_Upgrade_Scripts.";
			var upgradeSchemaScripts = this.GetResourceNameUnderLocation(UPGRADE_GENERATED_FOLDER);
			var sortByVersionScripts = new SortedDictionary<string, EmbeddedResourceName>(upgradeSchemaScripts, new UpgradeFileNameComparer());

			//Run the generated upgrades
			foreach (EmbeddedResourceName ern in sortByVersionScripts.Values)
			{
				if (new Version(ern.FileName).CompareTo(_previousVersion) > 0)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
		}

		private void UpgradeFolder3()
		{
			UpgradeFolder3(null);
		}

		private void UpgradeFolder3(StringBuilder sb)
		{
			const string MAIN_FOLDER = "._3_GeneratedTablesAndData.";
			const string CREATE_SCHEMA_FILE = MAIN_FOLDER + "CreateSchema.sql";
			const string TRIGGER_FILE = MAIN_FOLDER + "CreateSchemaAuditTriggers.sql";
			const string STATIC_DATA_FILE = MAIN_FOLDER + "CreateData.sql";

			//Do not run installation scripts if versions match
			if (_previousVersion.Equals(_upgradeToVersion))
				return;

			try
			{
				//Run the create schema
				var scripts = this.GetResourceNameUnderLocation(CREATE_SCHEMA_FILE);
				foreach (EmbeddedResourceName ern in scripts.Values)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName).ToList().ForEach(s => AppendCleanScript(s, sb));
				}

				//Run the static data
				scripts = this.GetResourceNameUnderLocation(STATIC_DATA_FILE);
				foreach (var ern in scripts.Values)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName).ToList().ForEach(s => AppendCleanScript(s, sb));
				}

				//Run the triggers
				scripts = this.GetResourceNameUnderLocation(TRIGGER_FILE);
				foreach (var ern in scripts.Values)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			catch (Exception ex) { throw; }
		}

		private void UpgradeFolder4()
		{
			UpgradeFolder4(null);
		}

		private void UpgradeFolder4(StringBuilder sb)
		{
			const string MAIN_FOLDER = "._4_UserDefinedPostTablesAndData.";
			const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
			const string NEWDATABASE_FOLDER = MAIN_FOLDER + "NewDatabase";
			const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
			const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

			if (_newInstall) //NEW DATABASE
			{
				var scripts = this.GetResourceNameUnderLocation(NEWDATABASE_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else //VERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

			//RUN ALWAYS
			{
				var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

		}

		private void UpgradeFolder5()
		{
			UpgradeFolder5(null);
		}

		/// <summary>
		/// Run Model/User-Defined Scripts from Programmability
		/// </summary>
		private void UpgradeFolder5(StringBuilder sb)
		{
			const string MAIN_FOLDER = "._5_Programmability.";

			//Run user-defined objects and get determine an order for them if necessary (on failure)
			var failedScripts = new List<KeyValuePair<Guid, string>>();
			var sucessOrderScripts = new List<Guid>();

			//User-defined (Manually Added)
			var alluserDefinedScripts = GetUserDefinedScripts(MAIN_FOLDER + "Stored_Procedures.User_Defined");
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Views.User_Defined")).ToDictionary(x => x.Key, x => x.Value);
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Functions.User_Defined")).ToDictionary(x => x.Key, x => x.Value);

			//Model (managed)
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Stored_Procedures.Model")).ToDictionary(x => x.Key, x => x.Value);
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Views.Model")).ToDictionary(x => x.Key, x => x.Value);
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Functions.Model")).ToDictionary(x => x.Key, x => x.Value);

			if (sb == null)
			{
				this.ReinstallUserDefinedScripts(this.ReorderScripts(alluserDefinedScripts), failedScripts, sucessOrderScripts);
				this.RunErrors(failedScripts, sucessOrderScripts);
			}
			else
			{
				this.ReorderScripts(alluserDefinedScripts).ForEach(x => AppendCleanScript(x.Value, sb));
			}

			//Run internal objects last. They should always work
			this.ReinstallStoredProceduresInternal(null, sb);
		}

		private void UpgradeFolder6()
		{
			UpgradeFolder6(null);
		}

		private void UpgradeFolder6(StringBuilder sb)
		{
			const string MAIN_FOLDER = "._6_UserDefinedFinalize.";
			const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
			const string NEWDATABASE_FOLDER = MAIN_FOLDER + "NewDatabase";
			const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
			const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

			if (_newInstall) //NEW DATABASE
			{
				var scripts = this.GetResourceNameUnderLocation(NEWDATABASE_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else //VERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

			//RUN ALWAYS
			{
				var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file);
					else SqlServers.ReadSQLFileSectionsFromResource(file).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

		}

		private void RunErrors(List<KeyValuePair<Guid, string>> failedScripts)
		{
			RunErrors(failedScripts, null);
		}

		private void RunErrors(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> sucessOrderScripts)
		{
			if (failedScripts.Count == 0) return;
			var runFailed = true;
			do
			{
				var _scripts2 = new List<KeyValuePair<Guid, string>>();
				foreach (var item in failedScripts)
				{
					var key = item.Key;
					var sql = item.Value;
					SqlServers.ExecuteSQL(_connection, _transaction, sql, _scripts2, sucessOrderScripts);
				}
				runFailed = (_scripts2.Count < failedScripts.Count && _scripts2.Count > 0);
				failedScripts = _scripts2;
			} while (runFailed);

			if (failedScripts.Count > 0)
			{
				//This will throw a proper error
				SqlServers.ExecuteSQL(_connection, _transaction, failedScripts.First().Value);
			}
			else if (sucessOrderScripts != null)
			{
				var nOrderFile = System.IO.Path.Combine(new System.IO.FileInfo(System.Reflection.Assembly.GetExecutingAssembly().Location).DirectoryName, "installer.norder");
				//If there are no failures then ensure that there is no "norder" file
				if (System.IO.File.Exists(nOrderFile))
					System.IO.File.Delete(nOrderFile);

				//On success, write the XML file with the proper order
				try
				{
					var document = new System.Xml.XmlDocument();
					document.LoadXml("<root type=\"installer\"></root>");
					document.DocumentElement.AppendChild(document.CreateWhitespace("\r\n"));
					foreach (var k in sucessOrderScripts)
					{
						document.DocumentElement.AddElement("key", k.ToString());
						document.DocumentElement.AppendChild(document.CreateWhitespace("\r\n"));
					}
					document.Save(nOrderFile);
				}
				catch (Exception ex) { }
			}
		}

		#region Get Internal Objects

		private void ReinstallStoredProceduresInternal(List<KeyValuePair<Guid, string>> failedScripts, StringBuilder sb)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation("._5_Programmability.Stored_Procedures.Internal");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts);
						else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName).ToList().ForEach(s => AppendCleanScript(s, sb));
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch { throw; }
		}

		#endregion

		#region Get User-Defined Objects

		private Dictionary<string, List<string>> GetUserDefinedScripts(string subFolder)
		{
			try
			{
				var retval = new Dictionary<string, List<string>>();
				var storedProcedures = this.GetResourceNameUnderLocation(subFolder);
				foreach (var ern in storedProcedures.Values)
				{
					try
					{
						//Skip Internal
						if (!ern.FullName.Contains(subFolder + ".Internal"))
							retval.Add(ern.FullName, SqlServers.GetEmbeddedScripts(ern.FullName));
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
				return retval;
			}
			catch { throw; }
		}
		
		private List<KeyValuePair<string, string>> ReorderScripts(Dictionary<string, List<string>> allScripts)
		{
			var l = this.GetResourceNameUnderLocation("._5_Programmability.ScriptOrder.nOrder");
			var reorderedScripts = new Dictionary<string, List<string>>();
			var retval = new List<KeyValuePair<string, string>>();

			#region Create an unordered flat list
			var flatList = new List<KeyValuePair<string, string>>();
			foreach (var k in allScripts.Keys)
			{
				foreach (var v in allScripts[k])
				{
					flatList.Add(new KeyValuePair<string, string>(k, v));
				}
			}
			#endregion

			if (l.Values.Count > 0)
			{
				var xml = SqlServers.GetEmbeddedResource(l.Values.First().FullName);
				var document = new XmlDocument();
				try
				{
					//Load the ordered key list
					document.LoadXml(xml);

					//Loop through ordered key list and put scripts in order
					foreach (XmlNode n in document.DocumentElement.ChildNodes)
					{
						//Find a script with the specified key
						var scriptMatch = flatList.Where(x => x.Value.Contains(n.InnerText)).ToList();
						foreach (var script in scriptMatch)
						{
							//if the script is found move it to the top of the list
							retval.Add(script);

							//remove this item from the unordered list
							flatList.Remove(script);
						}
					}

					//Now that we have ordered the scripts and removed the originals now prepend the ordered list to the top of the scripts list
					retval.AddRange(flatList);
				}
				catch (Exception ex)
				{
					//Do Nothing
				}
			}
			else
			{
				retval = flatList;
			}
			return retval;
		}

		private void ReinstallUserDefinedScripts(List<KeyValuePair<string, string>> allScripts, List<KeyValuePair<Guid, string>> failedScripts, List<Guid> sucessOrderScripts)
		{
			//Run all the scripts
			for (var ii = 0; ii < allScripts.Count; ii++)
			{
				var scriptItem = allScripts[ii];
				SqlServers.ExecuteSQL(_connection, _transaction, scriptItem.Value, failedScripts, sucessOrderScripts);
			}
		}

		private void ReinstallStoredProceduresUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> sucessOrderScripts)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation(".Stored_Procedures");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						//Skip Intenal
						if (!ern.FullName.Contains(".Stored_Procedures.Internal"))
							SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, sucessOrderScripts);
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch { throw; }
		}

		private void ReinstallFunctionsUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> sucessOrderScripts)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation(".Functions");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						//Skip Intenal
						if (!ern.FullName.Contains(".Functions.Internal"))
							SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, sucessOrderScripts);
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Function Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch { throw; }
		}

		private void ReinstallViewsUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> sucessOrderScripts)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation(".Views");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						//Skip Intenal
						if (!ern.FullName.Contains(".Views.Internal"))
							SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, sucessOrderScripts);
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch { throw; }
		}

		#endregion

		private SortedDictionary<string, EmbeddedResourceName> GetResourceNameUnderLocation(string location)
		{
			var excludePathList = new List<string>();
			return GetResourceNameUnderLocation(location, excludePathList);
		}

		private SortedDictionary<string, EmbeddedResourceName> GetResourceNameUnderLocation(string location, List<string> excludePathList)
		{
			try
			{
				var retVal = new SortedDictionary<string, EmbeddedResourceName>();
				foreach (EmbeddedResourceName ern in _resourceNames)
				{
					if (ern.AsmLocation.StartsWith(location))
					{
						bool exclude = false;
						foreach (string path in excludePathList)
						{
							if (ern.AsmLocation.StartsWith(path))
								exclude = true;
						}

						if (!exclude) retVal.Add(ern.FullName, ern);
					}
				}
				return retVal;
			}
			catch { throw; }

		}

		private SortedDictionary<string, EmbeddedResourceName> GetResourceFileNameContains(string fileNamePart)
		{
			var retVal = new SortedDictionary<string, EmbeddedResourceName>();
			foreach (EmbeddedResourceName ern in _resourceNames)
			{
				if (ern.FileName.Contains(fileNamePart))
				{
					retVal.Add(ern.FileName, ern);
				}
			}
			return retVal;
		}

		#region UpgradeFileNameComparer class
		private class UpgradeFileNameComparer : IComparer<string>
		{
			#region IComparer<string> Members
			public int Compare(string x, string y)
			{
				return new UpgradeInstaller.Version(x).CompareTo(new UpgradeInstaller.Version(y));
			}
			#endregion
		}
		#endregion

		#region Version Class
		internal class Version : IComparable<Version>
		{
			#region member variables
			int _major = 0;
			int _minor = 0;
			int _revision = 0;
			int _build = 0;
			int _generated = 0;
			#endregion

			#region Constructors

			public Version()
			{
			}

			public Version(int major, int minor, int revision, int build)
				: this()
			{
				_major = major;
				_minor = minor;
				_revision = revision;
				_build = build;
			}

			public Version(int major, int minor, int revision, int build, int generated)
				: this(major, minor, revision, build)
			{
				_generated = generated;
			}

			public Version(Version version)
			{
				_build = version._build;
				_generated = version._generated;
				_major = version._major;
				_minor = version._minor;
				_revision = version._revision;
			}

			public Version(string[] versionSplit)
				: this()
			{
				if (versionSplit.Length > 0) int.TryParse(versionSplit[0], out _major);
				if (versionSplit.Length > 1) int.TryParse(versionSplit[1], out _minor);
				if (versionSplit.Length > 2) int.TryParse(versionSplit[2], out _revision);
				if (versionSplit.Length > 3) int.TryParse(versionSplit[3], out _build);
				if (versionSplit.Length > 4) int.TryParse(versionSplit[4], out _generated);
			}

			public Version(string fileName)
			{
				try
				{
					var arr1 = fileName.Split('.');
					if (arr1.Length >= 1)
					{
						string[] versionSplit = null;

						if (arr1.Length == 1)
							versionSplit = arr1[0].Split('_');
						else
							versionSplit = arr1[arr1.Length - 2].Split('_');

						if (versionSplit.Length >= 5)
						{
							if (versionSplit.Length > 0) int.TryParse(versionSplit[0], out _major);
							if (versionSplit.Length > 1) int.TryParse(versionSplit[1], out _minor);
							if (versionSplit.Length > 2) int.TryParse(versionSplit[2], out _revision);
							if (versionSplit.Length > 3) int.TryParse(versionSplit[3], out _build);
							if (versionSplit.Length > 4) int.TryParse(versionSplit[4], out _generated);
							return;
						}
					}
					_major = -45;
				}
				catch { }
			}

			#endregion

			#region Properties

			public int Major
			{
				get { return _major; }
				set { _major = value; }
			}

			public int Minor
			{
				get { return _minor; }
				set { _minor = value; }
			}

			public int Revision
			{
				get { return _revision; }
				set { _revision = value; }
			}

			public int Build
			{
				get { return _build; }
				set { _build = value; }
			}

			public int Generated
			{
				get { return _generated; }
				set { _generated = value; }
			}

			#endregion

			#region IComparable<Version> Members
			public int CompareTo(Version other)
			{
				if (this.Major != other.Major)
					return this.Major.CompareTo(other.Major);
				else if (this.Minor != other.Minor)
					return this.Minor.CompareTo(other.Minor);
				else if (this.Revision != other.Revision)
					return this.Revision.CompareTo(other.Revision);
				else if (this.Build != other.Build)
					return this.Build.CompareTo(other.Build);
				else if (this.Generated != other.Generated)
					return this.Generated.CompareTo(other.Generated);
				else
					return 0;
			}
			#endregion

			#region Methods

			public override bool Equals(object obj)
			{
				if (!(obj is Version)) return false;
				var v = (Version)obj;
				return (v.Build == this.Build) &&
					(v.Generated == this.Generated) &&
					(v.Major == this.Major) &&
					(v.Minor == this.Minor) &&
					(v.Revision == this.Revision);
			}

			public override int GetHashCode()
			{
				return base.GetHashCode();
			}

			public string ToString(string seperationChars)
			{
				string retval = this.Major + seperationChars + this.Minor + seperationChars + this.Revision + seperationChars + this.Build;
				if (this.Generated != 0) retval += seperationChars + this.Generated;
				return retval;
			}

			public override string ToString()
			{
				return this.ToString(".");
			}

			#endregion

			#region Operators

			public static bool operator <(Version r1, Version r2)
			{
				if ((object)r1 == null && (object)r2 == null) return false;
				if ((object)r1 == null ^ (object)r2 == null) return false;

				if (r1.Major < r2.Major) return true;
				if (r1.Major > r2.Major) return false;

				if (r1.Minor < r2.Minor) return true;
				if (r1.Minor > r2.Minor) return false;

				if (r1.Revision < r2.Revision) return true;
				if (r1.Revision > r2.Revision) return false;

				if (r1.Build < r2.Build) return true;
				if (r1.Build > r2.Build) return false;

				if (r1.Generated < r2.Generated) return true;
				if (r1.Generated > r2.Generated) return false;

				return false;
			}

			public static bool operator >(Version r1, Version r2)
			{
				if ((object)r1 == null && (object)r2 == null) return false;
				if ((object)r1 == null ^ (object)r2 == null) return false;

				if (r1.Major > r2.Major) return true;
				if (r1.Major < r2.Major) return false;

				if (r1.Minor > r2.Minor) return true;
				if (r1.Minor < r2.Minor) return false;

				if (r1.Revision > r2.Revision) return true;
				if (r1.Revision < r2.Revision) return false;

				if (r1.Build > r2.Build) return true;
				if (r1.Build < r2.Build) return false;

				if (r1.Generated > r2.Generated) return true;
				if (r1.Generated < r2.Generated) return false;

				return false;
			}

			public static bool operator ==(Version r1, Version r2)
			{
				if ((object)r1 == null && (object)r2 == null) return true;
				if ((object)r1 == null ^ (object)r2 == null) return false;
				if (r1 < r2) return false;
				if (r1 > r2) return false;
				return true;
			}

			public static bool operator !=(Version r1, Version r2)
			{
				if ((object)r1 == null && (object)r2 == null) return false;
				if ((object)r1 == null ^ (object)r2 == null) return true;
				if (r1 < r2) return true;
				if (r1 > r2) return true;
				return false;
			}

			#endregion

		}
		#endregion

		#region EmbeddedResourceName class
		private class EmbeddedResourceName
		{
			#region Members
			private string _fullName;
			private string _fileName;
			private string _fileExtension;
			private string _asmLocation;
			private string _asmNamespace;
			#endregion

			#region Constructors
			public EmbeddedResourceName(string fullName)
			{
				string[] splitName = fullName.Split('.');
				_fullName = fullName;
				_fileName = splitName[splitName.Length - 2];
				_fileExtension = splitName[splitName.Length - 1];
				_asmNamespace = DEFAULT_NAMESPACE;
				int namespaceCount = DEFAULT_NAMESPACE.Split('.').Length;
				_asmLocation = string.Empty;
				for (var ii = namespaceCount; ii < splitName.Length; ii++)
				{
					_asmLocation += "." + splitName[ii];
				}
				_asmLocation.Trim(new char[] { '.' });
			}
			#endregion

			#region Properties
			public string FullName
			{
				get { return _fullName; }
			}

			public string FileName
			{
				get { return _fileName; }
			}

			public string FileExtension
			{
				get { return _fileExtension; }
			}

			public string AsmLocation
			{
				get { return _asmLocation; }
			}

			public string AsmNamespace
			{
				get { return _asmNamespace; }
			}
			#endregion
		}
		#endregion

	}
}
#pragma warning restore 0168