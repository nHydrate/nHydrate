//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 0168
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Security.Cryptography;
using System.IO;
using Npgsql;
using Serilog;

namespace PROJECTNAMESPACE
{
    /// <summary>
    /// Provides installation functionality for databases
    /// </summary>
    internal class UpgradeInstaller
    {
        #region member variables

        internal static readonly GeneratedVersion _def_Version = new GeneratedVersion(-1, -1, -1, -1, -1);

        internal const string DEFAULT_NAMESPACE = "PROJECTNAMESPACE";
        internal const string MODELKEY = "%MODELKEY%";
        private GeneratedVersion _previousVersion = null;
        private static GeneratedVersion _upgradeToVersion = new GeneratedVersion("UPGRADE_VERSION");
        private InstallSetup _setup = null;
        private NpgsqlConnection _connection;
        private NpgsqlTransaction _transaction;
        private List<EmbeddedResourceName> _resourceNames = new List<EmbeddedResourceName>();
        private nHydrateDbObjectList _databaseItems = new nHydrateDbObjectList();
        private List<string> _newItems = new List<string>();

        private const string UPGRADE_GENERATED_FOLDER = "._2_Upgrade_Scripts.";

        #endregion

        private static GeneratedVersion UpgradeToVersion
        {
            get { return UpgradeInstaller._upgradeToVersion; }
        }

        /// <summary>
        /// Upgrades a database to the newest schema
        /// </summary>
        public static void UpgradeDatabase(InstallSetup setup)
        {
            #region Verify that the database can be opened

            //Try this 10 times and then fail
            var isError = true;
            while (isError)
            {
                try
                {
                    var settings = new nHydrateSetting();
                    settings.Load(setup.ConnectionString);
                    isError = false;
                }
                catch (Exception ex)
                {
                    System.Threading.Thread.Sleep(500);
                    isError = true;
                }
            }

            #endregion

            try
            {
                var upgradeInstaller = new UpgradeInstaller(setup);
                upgradeInstaller.Initialize();
                upgradeInstaller.RunUpgrade(setup);
            }
            catch (InvalidSQLException ex)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw;
            }
        }

        #region construct / initialize

        private UpgradeInstaller(InstallSetup setup)
        {
            if (setup == null)
                throw new Exception("The setup object cannot be null.");

            if (setup.Version == null)
                _previousVersion = new GeneratedVersion(_def_Version);
            else
                _previousVersion = setup.Version;
            _setup = setup;
        }

        private void Initialize()
        {
            var settings = new nHydrateSetting();
            if (_setup.Version == null)
            {
                settings.Load(_setup.ConnectionString);
            }
            else
            {
                settings.dbVersion = _setup.Version.ToString();
                settings.ModelKey = new Guid(MODELKEY);
            }

            //Verify that this is the proper database for this model, if there is a previous key
            if (settings.ModelKey != Guid.Empty)
            {
                if (settings.ModelKey != new Guid(MODELKEY))
                {
                    //TODO: Add way to override with parameters
                    Log.Information("The database being updated was created against a different model. This may cause database versioning issues");
                    return;
                }
            }

            if (settings.dbVersion != string.Empty)
            {
                string[] versionNumbers = settings.dbVersion.Split('.');
                _previousVersion = new GeneratedVersion();
                _previousVersion.Major = int.Parse(versionNumbers[0]);
                _previousVersion.Minor = int.Parse(versionNumbers[1]);
                _previousVersion.Revision = int.Parse(versionNumbers[2]);
                _previousVersion.Build = int.Parse(versionNumbers[3]);
                if (versionNumbers.Length >= 5)
                    _previousVersion.Generated = int.Parse(versionNumbers[4]);
            }
            var assem = Assembly.GetExecutingAssembly();
            var resourceNames = assem.GetManifestResourceNames();
            foreach (string resourceName in resourceNames)
            {
                var ern = new EmbeddedResourceName(resourceName);
                _resourceNames.Add(ern);
            }
        }

        #endregion

        public static string GetScript(InstallSetup setup)
        {
            var tempsSections = new List<string>();
            var upgradeInstaller = new UpgradeInstaller(setup);
            upgradeInstaller.Initialize();
            upgradeInstaller._databaseItems = nHydrateDbObject.Load(setup.ConnectionString, MODELKEY, null);
            var sb = new StringBuilder();
            upgradeInstaller.UpgradeFolder1(sb, setup);
            upgradeInstaller.UpgradeFolder2(sb, setup);
            upgradeInstaller.UpgradeFolder3(sb, setup);
            upgradeInstaller.UpgradeFolder4(sb, setup);
            upgradeInstaller.UpgradeFolder5(sb, setup);
            upgradeInstaller.UpgradeFolder6(sb, setup);

            var settings = new nHydrateSetting();
            settings.dbVersion = UpgradeInstaller.UpgradeToVersion.ToString(".");
            settings.LastUpdate = DateTime.Now;
            settings.ModelKey = new Guid(MODELKEY);
            settings.History.Add(new HistoryItem()
            {
                Version = UpgradeInstaller.UpgradeToVersion.ToString("."),
                PublishDate = DateTime.Now
            });
            sb.AppendLine(settings.GetVersionUpdateScript());
            sb.AppendLine("--GO");

            //Create the table if need be
            sb.AppendLine("CREATE TABLE IF NOT EXISTS \"__nhydrateobjects\"");
            sb.AppendLine("(rowid bigint GENERATED BY DEFAULT AS IDENTITY,");
            sb.AppendLine("\"id\" UUID NULL,");
            sb.AppendLine("\"name\" varchar (450) NOT NULL,");
            sb.AppendLine("\"type\" varchar (10) NOT NULL,");
            sb.AppendLine("\"schema\" varchar (450) NULL,");
            sb.AppendLine("\"CreatedDate\" timestamp NOT NULL,");
            sb.AppendLine("\"ModifiedDate\" timestamp NOT NULL,");
            sb.AppendLine("\"Hash\" varchar (32) NULL,");
            sb.AppendLine("\"Status\" varchar (500) NULL,");
            sb.AppendLine("\"ModelKey\" UUID NOT NULL);");
            sb.AppendLine();
            sb.AppendLine("--GO");

            //Add DB objects
            sb.AppendLine();
            foreach (var item in upgradeInstaller._databaseItems.Where(x => x.Changed))
            {
                var sql = "if exists(select * from [__nhydrateobjects] where [id] = '" + item.id + "') " +
                             "update [__nhydrateobjects] set [name] = '" + item.name + "', [type] = '" + item.type + "', [schema] = '" + item.schema + "', [CreatedDate] = '" + item.CreatedDate.ToString("yyyy-MM-dd HH:mm:ss") + "', [ModifiedDate] = '" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + "', [Hash] = '" + item.Hash + "', [ModelKey] = '" + item.ModelKey + "', [Status] = '" + item.Status + "' where [id] = '" + item.id + "' " +
                             "else " +
                             "insert into [__nhydrateobjects] ([id], [name], [type], [schema], [CreatedDate], [ModifiedDate], [Hash], [ModelKey], [Status]) values ('" + item.id + "', '" + item.name + "', '" + item.type + "', '" + item.schema + "', '" + item.CreatedDate.ToString("yyyy-MM-dd HH:mm:ss") + "', '" + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") + "', '" + item.Hash + "', '" + item.ModelKey + "', '" + item.Status + "')";
                sb.AppendLine(sql);
            }
            sb.AppendLine("--GO");
            sb.AppendLine();

            try
            {
                var s = sb.ToString().Replace("--DO NOT MODIFY THIS FILE. IT IS ALWAYS OVERWRITTEN ON GENERATION.\r\n", string.Empty);
                while (s.StartsWith("\r\n"))
                {
                    s = s.Substring(2);
                }
                while (s.StartsWith("--GO\r\n"))
                {
                    s = s.Substring(4);
                }
                return s;
            }
            catch (Exception ex)
            {
                return sb.ToString();
            }
        }

        public static bool NeedsUpdate(string connectionString)
        {
            var settings = new nHydrateSetting();
            settings.Load(connectionString);
            if (!settings.IsLoaded) return true; //Cannot find version so upgrade

            var currentDbVersion = _def_Version;
            if (!string.IsNullOrEmpty(settings.dbVersion))
                currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));
            else
                return true;

            return (currentDbVersion < UpgradeInstaller.UpgradeToVersion);
        }

        public static string VersionInstalled(string connectionString)
        {
            var settings = new nHydrateSetting();
            settings.Load(connectionString);
            var currentDbVersion = _def_Version;
            if (settings.IsLoaded)
            {
                if (!string.IsNullOrEmpty(settings.dbVersion))
                    currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));
            }
            return currentDbVersion.ToString();
        }

        public static string VersionLatest()
        {
            return _upgradeToVersion.ToString();
        }

        public static bool IsVersioned(string connectionString)
        {
            var settings = new nHydrateSetting();
            settings.Load(connectionString);
            var currentDbVersion = _def_Version;
            if (settings.IsLoaded)
            {
                if (!string.IsNullOrEmpty(settings.dbVersion))
                    currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));
            }
            return (currentDbVersion != _def_Version);
        }

        private void RunUpgrade(InstallSetup setup)
        {
            if (setup.Transaction == null || !setup.UseTransaction)
            {
                _connection = new NpgsqlConnection(setup.ConnectionString);
                _connection.Open();
                if (setup.UseTransaction)
                    _transaction = _connection.BeginTransaction();
            }
            //TODO: Allow user to specify an open transaction
            //else //transaction is NOT null AND UseTransaction is TRUE
            //{
            //    _connection = setup.Transaction.Connection;
            //    _transaction = setup.Transaction;
            //}

            _databaseItems = nHydrateDbObject.Load(setup.ConnectionString, MODELKEY, _transaction);
            var timer = new System.Diagnostics.Stopwatch();

            try
            {
                var settings = new nHydrateSetting();
                settings.Load(setup.ConnectionString);

                var currentDbVersion = _def_Version;
                if (!string.IsNullOrEmpty(settings.dbVersion))
                    currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));

                if (currentDbVersion > _upgradeToVersion)
                {
                    Log.Information($"The current database version ({currentDbVersion}) is greater than the current library ({_upgradeToVersion}). The upgrade will not proceed.");
                    return;
                }

                #region Verify Upgrade Scripts

                //Do not show prompts for old scripts, since there is no way to verify
                if (settings.WasLegacy)
                {
                    setup.AcceptVersionWarningsChangedScripts = true;
                    setup.AcceptVersionWarningsNewScripts = true;
                }

                //Test Upgrades for missed scripts
                var upgradeSchemaScripts = this.GetResourceNameUnderLocation(UPGRADE_GENERATED_FOLDER);
                var sortByVersionScripts = new SortedDictionary<string, EmbeddedResourceName>(upgradeSchemaScripts, new UpgradeFileNameComparer());
                foreach (var item in sortByVersionScripts)
                {
                    var hashValue = string.Join("\r\n--GO\r\n", DatabaseServer.ReadSQLFileSectionsFromResource(item.Key, setup)).CalculateMD5Hash();
                    var fileName = item.Key.Substring(item.Key.IndexOf(UPGRADE_GENERATED_FOLDER) + UPGRADE_GENERATED_FOLDER.Length, item.Key.Length - (item.Key.IndexOf(UPGRADE_GENERATED_FOLDER) + UPGRADE_GENERATED_FOLDER.Length));
                    var di = _databaseItems.FirstOrDefault(x => x.name == item.Key);

                    if (di == null) //Just in case the version name is formatted differently
                    {
                        di = _databaseItems.FirstOrDefault(x => (new GeneratedVersion(x.name)).ToString() == (new GeneratedVersion(item.Key)).ToString());
                        if (di != null) di.name = item.Key;
                    }

                    if (di == null)
                    {
                        var fileVersion = new GeneratedVersion(fileName);
                        if ((new GeneratedVersion(settings.dbVersion.Split('.'))) > fileVersion)
                        {
                            //script is in installer but never run on database
                            if (!setup.AcceptVersionWarningsNewScripts && !setup.CheckOnly)
                            {
                                throw new ScriptDifferenceException($"The script '{fileName}' has never been applied to the database and never will due to its version.");
                            }
                            _databaseItems.Add(new nHydrateDbObject()
                            {
                                name = item.Key,
                                type = "FILE",
                                Hash = hashValue,
                                ModelKey = new Guid(MODELKEY),
                                Status = "skipped:upgrade",
                                Changed = true,
                            });
                            UpgradeInstaller.LogInfo($"The script '{fileName}' has never been applied to the database and never will due to its version.");
                        }
                    }
                    else if (di.Hash != hashValue)
                    {
                        //Said script is in installer and was run but the installer version is different than what was run
                        if (!setup.AcceptVersionWarningsChangedScripts && !setup.CheckOnly)
                        {
                            Log.Information($"The script '{fileName}' is different than the one run on the database.");
                            return;
                        }
                        di.Hash = hashValue;
                        di.Status = "versiondiff:upgrade";
                        di.Changed = true;
                        UpgradeInstaller.LogInfo($"The script '{fileName}' is different than the one run on the database.");
                    }
                }

                #endregion

                timer.Stop();
                timer.Reset();
                timer.Start();

                #region 1_UserDefinedInitialization

                this.UpgradeFolder1(setup);

                #endregion

                #region 2_Upgrade Scripts

                this.UpgradeFolder2(setup);

                #endregion

                #region 3_GeneratedTablesAndData

                this.UpgradeFolder3(setup);

                #endregion

                #region 4_UserDefinedPostTablesAndData

                this.UpgradeFolder4(setup);

                #endregion

                #region 5_Programmability

                UpgradeFolder5(setup);

                #endregion

                #region 6_UserDefinedFinalize

                UpgradeFolder6(setup);

                #endregion

                if (!setup.CheckOnly)
                    nHydrateDbObject.Save(setup.ConnectionString, MODELKEY, _databaseItems, _transaction);

                if (_transaction != null && !setup.CheckOnly)
                    _transaction.Commit();
                else if (_transaction != null && setup.CheckOnly)
                    _transaction.Rollback();

                if (setup.CheckOnly)
                {
                    var sb = new StringBuilder();
                    _newItems.ForEach(x => sb.AppendLine($"New script: {x}"));
                    _databaseItems.OrderBy(x => x.name).Where(x => x.Changed && !_newItems.Contains(x.name)).ToList().ForEach(x => sb.AppendLine("Changed script: " + x.name + " (" + x.Status + ")"));
                    if (!string.IsNullOrEmpty(sb.ToString()))
                    {
                        throw new Exception(sb.ToString());
                    }
                }
                else
                {
                    settings.dbVersion = _upgradeToVersion.ToString(".");
                    settings.LastUpdate = DateTime.Now;
                    settings.ModelKey = new Guid(MODELKEY);
                    if (!settings.History.Any(x => x.Version == _upgradeToVersion.ToString(".")))
                    {
                        settings.History.Add(new HistoryItem()
                        {
                            Version = _upgradeToVersion.ToString("."),
                            PublishDate = DateTime.Now
                        });
                    }
                    settings.Save(setup.ConnectionString);
                }

                timer.Stop();
                LogInfo($"Installation Complete, Model: {MODELKEY}, Elapsed time: {timer.ElapsedMilliseconds}");
            }
            catch (InvalidSQLException ex)
            {
                try
                {
                    if (_transaction != null)
                        _transaction.Rollback();
                }
                catch { }
                Log.Error(ex.ToString());
                throw;
            }
            catch (Exception ex)
            {
                try
                {
                    if (_transaction != null)
                        _transaction.Rollback();
                }
                catch { }
                Log.Error(ex.ToString());
                throw;
            }
            finally
            {
                _connection.Close();
                _connection.Dispose();
                if (_transaction != null) _transaction.Dispose();
            }

        }

        private void AppendCleanScript(string key, string script, StringBuilder sb)
        {
            if (string.IsNullOrEmpty(script)) return;
            var current = _databaseItems.FirstOrDefault(x => x.name.ToLower() == key.ToLower());

            var tempdb = new StringBuilder();
            var lines = script.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);
            foreach (var s in lines)
            {
                if (!s.StartsWith("--MODELID"))
                    tempdb.AppendLine(s);
            }
            tempdb.AppendLine("--GO");
            sb.Append(tempdb.ToString());

            var hashValue = tempdb.ToString().CalculateMD5Hash();
            if (current != null)
            {
                if (current.Hash == hashValue)
                {
                    //Skip
                }
                else
                {
                    current.ModifiedDate = DateTime.Now;
                    current.Hash = hashValue;
                    current.Status = "applied";
                }
            }
            else
            {
                current = new nHydrateDbObject()
                {
                    name = key,
                    Hash = hashValue,
                    ModelKey = new Guid(UpgradeInstaller.MODELKEY),
                    type = "FILE",
                    Status = "applied",
                    Changed = true,
                };
                _databaseItems.Add(current);
            }
        }

        private void UpgradeFolder1(InstallSetup setup)
        {
            UpgradeFolder1(null, setup);
        }

        private void UpgradeFolder1(StringBuilder sb, InstallSetup setup)
        {
            const string MAIN_FOLDER = "._1_UserDefinedInitialization.";
            const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
            const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
            const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

            if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
            {
                var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
                foreach (var file in scripts.Keys)
                {
                    var hashItem = _databaseItems.FirstOrDefault(x => x.name == scripts[file].FullName);
                    if (hashItem == null) _newItems.Add(scripts[file].FullName);
                    if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(scripts[file].FullName, setup)))
                    {
                        if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
                        else DatabaseServer.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
                    }
                }
            }
            else //VERSIONED
            {
                var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
                foreach (var file in scripts.Keys)
                {
                    var hashItem = _databaseItems.FirstOrDefault(x => x.name == scripts[file].FullName);
                    if (hashItem == null) _newItems.Add(scripts[file].FullName);
                    if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(scripts[file].FullName, setup)))
                    {
                        if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
                        else DatabaseServer.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
                    }
                }
            }

            //RUN ALWAYS
            {
                var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
                foreach (var file in scripts.Keys)
                {
                    if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
                    else DatabaseServer.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
                }
            }

        }

        private void UpgradeFolder2(InstallSetup setup)
        {
            UpgradeFolder2(null, setup);
        }

        private void UpgradeFolder2(StringBuilder sb, InstallSetup setup)
        {
            if (_previousVersion == _def_Version) return; //existing db with no version table

            var upgradeSchemaScripts = this.GetResourceNameUnderLocation(UPGRADE_GENERATED_FOLDER);
            var sortByVersionScripts = new SortedDictionary<string, EmbeddedResourceName>(upgradeSchemaScripts, new UpgradeFileNameComparer());

            //Run the generated upgrades
            foreach (var ern in sortByVersionScripts.Values)
            {
                if (new GeneratedVersion(ern.FileName).CompareTo(_previousVersion) > 0)
                {
                    var hashItem = _databaseItems.FirstOrDefault(x => x.name == ern.FullName);
                    if (hashItem == null) _newItems.Add(ern.FullName);
                    if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(ern.FullName, setup)))
                    {
                        setup.DebugScriptName = ern.FullName;
                        if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, _databaseItems, setup);
                        else DatabaseServer.ReadSQLFileSectionsFromResource(ern.FullName, setup).ToList().ForEach(s => AppendCleanScript(ern.FullName, s, sb));
                    }
                }
            }
            setup.DebugScriptName = null;
        }

        private void UpgradeFolder3(InstallSetup setup)
        {
            UpgradeFolder3(null, setup);
        }

        private void UpgradeFolder3(StringBuilder sb, InstallSetup setup)
        {
            const string MAIN_FOLDER = "._3_GeneratedTablesAndData.";

            if (setup.SkipNormalize) return;

            var upgradeSchemaScripts = this.GetResourceNameUnderLocation(MAIN_FOLDER);
            var sortByVersionScripts = new SortedDictionary<string, EmbeddedResourceName>(upgradeSchemaScripts);

            try
            {
                //Run the create scripts
                foreach (var ern in sortByVersionScripts.Values)
                {
                    var hashItem = _databaseItems.FirstOrDefault(x => x.name == ern.FullName);
                    if (hashItem == null) _newItems.Add(ern.FullName);

                    //Always run relations in case removed in upgrade scripts
                    var skipHash = (ern.FileName == "3_CreateRelations");

                    if (!setup.UseHash || skipHash || (hashItem == null || hashItem.Hash != GetFileHash(ern.FullName, setup)))
                    {
                        setup.DebugScriptName = ern.FullName;
                        if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, _databaseItems, setup);
                        else DatabaseServer.ReadSQLFileSectionsFromResource(ern.FullName, setup).ToList().ForEach(s => AppendCleanScript(ern.FullName, s, sb));
                    }
                }
                setup.DebugScriptName = null;
            }
            catch (Exception ex)
            {
                throw;
            }
        }

        private void UpgradeFolder4(InstallSetup setup)
        {
            UpgradeFolder4(null, setup);
        }

        private void UpgradeFolder4(StringBuilder sb, InstallSetup setup)
        {
            const string MAIN_FOLDER = "._4_UserDefinedPostTablesAndData.";
            const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
            const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
            const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

            if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
            {
                var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
                foreach (var file in scripts.Keys)
                {
                    var hashItem = _databaseItems.FirstOrDefault(x => x.name == scripts[file].FullName);
                    if (hashItem == null) _newItems.Add(scripts[file].FullName);
                    if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(scripts[file].FullName, setup)))
                    {
                        if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
                        else DatabaseServer.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
                    }
                }
            }
            else //VERSIONED
            {
                var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
                foreach (var file in scripts.Keys)
                {
                    var hashItem = _databaseItems.FirstOrDefault(x => x.name == scripts[file].FullName);
                    if (hashItem == null) _newItems.Add(scripts[file].FullName);
                    if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(scripts[file].FullName, setup)))
                    {
                        if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
                        else DatabaseServer.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
                    }
                }
            }

            //RUN ALWAYS
            {
                var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
                foreach (var file in scripts.Keys)
                {
                    if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, file, null, _databaseItems, setup);
                    else DatabaseServer.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
                }
            }

        }

        private void UpgradeFolder5(InstallSetup setup)
        {
            UpgradeFolder5(null, setup);
        }

        /// <summary>
        /// Run Model/User-Defined Scripts from Programmability
        /// </summary>
        private void UpgradeFolder5(StringBuilder sb, InstallSetup setup)
        {
            const string MAIN_FOLDER = "._5_Programmability.";

            //Run user-defined objects and get determine an order for them if necessary (on failure)
            var failedScripts = new List<KeyValuePair<Guid, string>>();
            var successOrderScripts = new List<Guid>();

            //User-defined (Manually Added)
            Dictionary<string, List<string>> alluserDefinedScripts = GetUserDefinedScripts(MAIN_FOLDER + "Stored_Procedures.User_Defined", setup);
            alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Views.User_Defined", setup)).ToDictionary(x => x.Key, x => x.Value);
            alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Functions.User_Defined", setup)).ToDictionary(x => x.Key, x => x.Value);

            //Model (managed)
            alluserDefinedScripts = alluserDefinedScripts.Concat(ProcessInternalScripts(MAIN_FOLDER + "Stored_Procedures.Model", setup)).ToDictionary(x => x.Key, x => x.Value);
            alluserDefinedScripts = alluserDefinedScripts.Concat(ProcessInternalScripts(MAIN_FOLDER + "Views.Model", setup)).ToDictionary(x => x.Key, x => x.Value);
            alluserDefinedScripts = alluserDefinedScripts.Concat(ProcessInternalScripts(MAIN_FOLDER + "Functions.Model", setup)).ToDictionary(x => x.Key, x => x.Value);

            if (sb == null)
            {
                this.ReinstallUserDefinedScripts(this.ReorderScripts(alluserDefinedScripts), failedScripts, successOrderScripts, _databaseItems, setup);
                this.RunErrors(failedScripts, successOrderScripts, setup);
            }
            else
            {
                var list = this.ReorderScripts(alluserDefinedScripts);
                list.Keys.ToList().ForEach(key => AppendCleanScript(key, string.Join("\r\n--GO\r\n", list[key]), sb));
            }

            //Run internal objects last. They should always work
            this.ReinstallStoredProceduresInternal(null, sb, setup);
        }

        private void UpgradeFolder6(InstallSetup setup)
        {
            UpgradeFolder6(null, setup);
        }

        private void UpgradeFolder6(StringBuilder sb, InstallSetup setup)
        {
            const string MAIN_FOLDER = "._6_UserDefinedFinalize.";
            const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
            const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
            const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

            if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
            {
                var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
                foreach (var file in scripts.Keys)
                {
                    var hashItem = _databaseItems.FirstOrDefault(x => x.name == scripts[file].FullName);
                    if (hashItem == null) _newItems.Add(scripts[file].FullName);
                    if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(scripts[file].FullName, setup)))
                    {
                        if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, file, null, null, _databaseItems, setup);
                        else DatabaseServer.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
                    }
                }
            }
            else //VERSIONED
            {
                var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
                foreach (var file in scripts.Keys)
                {
                    var hashItem = _databaseItems.FirstOrDefault(x => x.name == scripts[file].FullName);
                    if (hashItem == null) _newItems.Add(scripts[file].FullName);
                    if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(scripts[file].FullName, setup)))
                    {
                        if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, file, null, null, _databaseItems, setup);
                        else DatabaseServer.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
                    }
                }
            }

            //RUN ALWAYS
            {
                var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
                foreach (var file in scripts.Keys)
                {
                    if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, file, null, null, _databaseItems, setup);
                    else DatabaseServer.ReadSQLFileSectionsFromResource(file, setup).ToList().ForEach(s => AppendCleanScript(file, s, sb));
                }
            }

        }

        private Dictionary<string, List<string>> ProcessInternalScripts(string scriptFolder, InstallSetup setup)
        {
            try
            {
                //Get each file from the folder
                var retval = new Dictionary<string, List<string>>();
                var scriptList = GetUserDefinedScripts(scriptFolder, setup);
                foreach (var script in scriptList)
                {
                    retval = retval.Concat(ParseInternalScripts(scriptList)).ToDictionary(x => x.Key, x => x.Value);
                }
                return retval;

            }
            catch (Exception ex)
            {
                throw;
            }
        }

        private Dictionary<string, List<string>> ParseInternalScripts(Dictionary<string, List<string>> list)
        {
            var retval = new Dictionary<string, List<string>>();
            var indexList = new Dictionary<string, int>(); //keeps track of the index when GUID are duplicate
            foreach (var key in list.Keys)
            {
                var sqlList = list[key];
                foreach (var sql in sqlList)
                {
                    var lines = sql.Split('\n');
                    var line = lines.FirstOrDefault(x => x.Contains("--MODELID,BODY:"));
                    if (string.IsNullOrEmpty(line))
                        line = lines.FirstOrDefault(x => x.Contains("--MODELID:"));

                    var itemId = key + "-" + key.CalculateMD5Hash().ToLower();
                    if (!string.IsNullOrEmpty(line))
                    {
                        try
                        {
                            line = line.Replace("--MODELID,BODY:", string.Empty).Replace("--MODELID:", string.Empty).Trim();
                            if (line.Length == 36) //Use the Model ID Guid
                                itemId = key + "-" + line.ToLower();
                        }
                        catch (Exception ex)
                        {
                            //Do Nothing
                        }
                    }

                    var currentIndex = 1;
                    if (indexList.ContainsKey(itemId))
                        currentIndex = ++indexList[itemId];
                    else
                        indexList.Add(itemId, currentIndex);

                    retval.Add(itemId + "-" + currentIndex, new List<string>(new[] { sql }));
                }
            }
            return retval;
        }

        private void RunErrors(List<KeyValuePair<Guid, string>> failedScripts, InstallSetup setup)
        {
            RunErrors(failedScripts, null, setup);
        }

        private void RunErrors(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, InstallSetup setup)
        {
            if (failedScripts.Count == 0) return;
            var runFailed = true;
            do
            {
                var _scripts2 = new List<KeyValuePair<Guid, string>>();
                foreach (var item in failedScripts)
                {
                    var key = item.Key;
                    var sql = item.Value;
                    DatabaseServer.ExecuteSQL(_connection, _transaction, sql, setup, _scripts2, successOrderScripts);
                }
                runFailed = (_scripts2.Count < failedScripts.Count && _scripts2.Count > 0);
                failedScripts = _scripts2;
            } while (runFailed);

            if (failedScripts.Count > 0)
            {
                //This will throw a proper error
                DatabaseServer.ExecuteSQL(_connection, _transaction, failedScripts.First().Value, setup);
                //Use this for debugging if necessary
                var sql = string.Join("\r\n\r\n--GO\r\n--SCRIPT BREAK\r\n\r\n", failedScripts.Select(x => x.Value));
            }
            else if (successOrderScripts != null)
            {
                //Only do this in debug
#if (DEBUG)
                if (System.Diagnostics.Debugger.IsAttached)
                {
                    var nOrderFile = System.IO.Path.Combine(new System.IO.FileInfo(System.Reflection.Assembly.GetExecutingAssembly().Location).DirectoryName, "installer.norder");
                    //If there are no failures then ensure that there is no "norder" file
                    if (System.IO.File.Exists(nOrderFile))
                        System.IO.File.Delete(nOrderFile);

                    //On success, write the XML file with the proper order
                    try
                    {
                        var document = new System.Xml.XmlDocument();
                        document.LoadXml("<root type=\"installer\"></root>");
                        document.DocumentElement.AppendChild(document.CreateWhitespace("\r\n"));
                        foreach (var k in successOrderScripts)
                        {
                            document.DocumentElement.AddElement("key", k.ToString());
                            document.DocumentElement.AppendChild(document.CreateWhitespace("\r\n"));
                        }
                        document.Save(nOrderFile);
                    }
                    catch (Exception ex)
                    {
                    }
                }
#endif
            }
        }

        #region Get Internal Objects

        private void ReinstallStoredProceduresInternal(List<KeyValuePair<Guid, string>> failedScripts, StringBuilder sb, InstallSetup setup)
        {
            try
            {
                var storedProcedures = this.GetResourceNameUnderLocation("._5_Programmability.Stored_Procedures.Internal");
                foreach (var ern in storedProcedures.Values)
                {
                    try
                    {
                        var hashItem = _databaseItems.FirstOrDefault(x => x.name == ern.FullName);
                        if (hashItem == null) _newItems.Add(ern.FullName);
                        if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(ern.FullName, setup)))
                        {
                            setup.DebugScriptName = ern.FullName;
                            if (sb == null) DatabaseServer.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, _databaseItems, setup);
                            else DatabaseServer.ReadSQLFileSectionsFromResource(ern.FullName, setup).ToList().ForEach(s => AppendCleanScript(ern.FullName, s, sb));
                        }
                        setup.DebugScriptName = null;
                    }
                    catch
                    {
                        //System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
                        throw;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        #endregion

        #region Get User-Defined Objects

        private Dictionary<string, List<string>> GetUserDefinedScripts(string subFolder, InstallSetup setup)
        {
            try
            {
                var retval = new Dictionary<string, List<string>>();
                var storedProcedures = this.GetResourceNameUnderLocation(subFolder);
                foreach (var ern in storedProcedures.Values)
                {
                    try
                    {
                        //Skip Internal
                        if (!ern.FullName.Contains(subFolder + ".Internal"))
                        {
                            var current = _databaseItems.FirstOrDefault(x => x.name.ToLower() == ern.FullName.ToLower());
                            var scripts = DatabaseServer.GetEmbeddedScripts(ern.FullName, setup);

                            #region Strip internal stuff for hashing
                            var script = string.Join("\r\n--GO\r\n", scripts);
                            var tempdb = new StringBuilder();
                            var lines = script.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);
                            foreach (var s in lines)
                            {
                                if (!s.StartsWith("--MODELID"))
                                    tempdb.AppendLine(s);
                            }
                            tempdb.AppendLine("--GO");
                            #endregion

                            var hashValue = GetFileHash(ern.FullName, setup);
                            if (setup.UseHash && current != null && current.Hash == hashValue)
                            {
                                //Skip item
                            }
                            else
                            {
                                if (current == null)
                                {
                                    current = new nHydrateDbObject()
                                    {
                                        name = ern.FullName,
                                        Hash = hashValue,
                                        ModelKey = new Guid(UpgradeInstaller.MODELKEY),
                                        type = "FILE",
                                    };
                                }
                                else
                                {
                                    current.Changed = true;
                                    current.Hash = hashValue;
                                }

                                retval.Add(ern.FullName, scripts);
                            }
                        }
                    }
                    catch
                    {
                        //System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
                        throw;
                    }
                }

                //Run in alpha order so the user can re-arrange if need be
                return retval.OrderBy(x => x.Key).ToDictionary(x => x.Key, x => x.Value);
            }
            catch
            {
                throw;
            }
        }

        private Dictionary<string, List<string>> ReorderScripts(Dictionary<string, List<string>> allScripts)
        {
            var l = this.GetResourceNameUnderLocation("._5_Programmability.ScriptOrder.nOrder");

            //Make a copy fo the input list
            var inputCopy = new Dictionary<string, List<string>>();
            allScripts.Keys.ToList().ForEach(x => inputCopy.Add(x, allScripts[x]));

            var reorderedScripts = new Dictionary<string, List<string>>();
            if (l.Values.Count > 0)
            {
                var xml = DatabaseServer.GetEmbeddedResource(l.Values.First().FullName);
                var document = new XmlDocument();
                try
                {
                    //Load the ordered key list
                    document.LoadXml(xml);

                    //Loop through ordered key list and put scripts in order
                    foreach (XmlNode n in document.DocumentElement.ChildNodes)
                    {
                        //Find a script with the specified key
                        var scriptMatch = allScripts.Where(x => string.Join(string.Empty, x.Value).ToLower().Contains(n.InnerText.ToLower())).ToList();
                        foreach (var script in scriptMatch)
                        {
                            //if the script is found move it to the top of the list
                            reorderedScripts.Add(script.Key, script.Value);

                            //remove this item from the unordered list
                            inputCopy.Remove(script.Key);
                        }
                    }

                    //Now that we have ordered the scripts and removed the originals now prepend the ordered list to the top of the scripts list
                    inputCopy.Keys.ToList().ForEach(x => reorderedScripts.Add(x, inputCopy[x]));
                }
                catch (Exception ex)
                {
                    //Do Nothing
                }
            }
            else
            {
                reorderedScripts = inputCopy;
            }

            return reorderedScripts;
        }

        private void ReinstallUserDefinedScripts(Dictionary<string, List<string>> allScripts, List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, nHydrateDbObjectList _databaseItems, InstallSetup setup)
        {
            //Run all the scripts
            var newHashList = new Dictionary<nHydrateDbObject, string>();
            foreach (var key in allScripts.Keys)
            {
                var scriptItem = allScripts[key];
                //These run every time
                //var hashItem = _databaseItems.FirstOrDefault(x => x.name == scriptItem.FullName);
                //if (hashItem == null) _newItems.Add(scriptItem.FullName);
                //if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(scriptItem.FullName, setup)))
                {
                    foreach (var sql in scriptItem)
                    {
                        DatabaseServer.ExecuteSQL(_connection, _transaction, sql, setup, failedScripts, successOrderScripts);
                    }
                }
            }

            foreach (var k in newHashList.Keys)
                _databaseItems.FirstOrDefault(x => x == k).Hash = newHashList[k];
        }

        private void ReinstallStoredProceduresUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, InstallSetup setup)
        {
            try
            {
                var scripts = this.GetResourceNameUnderLocation(".Stored_Procedures");
                foreach (var file in scripts.Keys)
                {
                    try
                    {
                        //Skip Internal
                        if (!scripts[file].FullName.Contains(".Stored_Procedures.Internal"))
                        {
                            var hashItem = _databaseItems.FirstOrDefault(x => x.name == scripts[file].FullName);
                            if (hashItem == null) _newItems.Add(scripts[file].FullName);
                            if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(scripts[file].FullName, setup)))
                            {
                                DatabaseServer.RunEmbeddedFile(_connection, _transaction, scripts[file].FullName, failedScripts, successOrderScripts, _databaseItems, setup);
                            }
                        }
                    }
                    catch
                    {
                        //System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
                        throw;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void ReinstallFunctionsUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, InstallSetup setup)
        {
            try
            {
                var scripts = this.GetResourceNameUnderLocation(".Functions");
                foreach (var file in scripts.Keys)
                {
                    try
                    {
                        //Skip Internal
                        if (!scripts[file].FullName.Contains(".Functions.Internal"))
                        {
                            var hashItem = _databaseItems.FirstOrDefault(x => x.name == scripts[file].FullName);
                            if (hashItem == null) _newItems.Add(scripts[file].FullName);
                            if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(scripts[file].FullName, setup)))
                            {
                                DatabaseServer.RunEmbeddedFile(_connection, _transaction, scripts[file].FullName, failedScripts, successOrderScripts, _databaseItems, setup);
                            }
                        }
                    }
                    catch
                    {
                        //System.Windows.Forms.MessageBox.Show("Function Fail: " + ern.FullName);
                        throw;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        private void ReinstallViewsUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, InstallSetup setup)
        {
            try
            {
                var scripts = this.GetResourceNameUnderLocation(".Views");
                foreach (var file in scripts.Keys)
                {
                    try
                    {
                        //Skip Internal
                        if (!scripts[file].FullName.Contains(".Views.Internal"))
                        {
                            var hashItem = _databaseItems.FirstOrDefault(x => x.name == scripts[file].FullName);
                            if (hashItem == null) _newItems.Add(scripts[file].FullName);
                            if (!setup.UseHash || (hashItem == null || hashItem.Hash != GetFileHash(scripts[file].FullName, setup)))
                            {
                                DatabaseServer.RunEmbeddedFile(_connection, _transaction, scripts[file].FullName, failedScripts, successOrderScripts, _databaseItems, setup);
                            }
                        }
                    }
                    catch
                    {
                        //System.Windows.Forms.MessageBox.Show("View Fail: " + ern.FullName);
                        throw;
                    }
                }
            }
            catch
            {
                throw;
            }
        }

        #endregion

        private SortedDictionary<string, EmbeddedResourceName> GetResourceNameUnderLocation(string location)
        {
            var excludePathList = new List<string>();
            return GetResourceNameUnderLocation(location, excludePathList);
        }

        private SortedDictionary<string, EmbeddedResourceName> GetResourceNameUnderLocation(string location, List<string> excludePathList)
        {
            try
            {
                var retVal = new SortedDictionary<string, EmbeddedResourceName>();
                foreach (EmbeddedResourceName ern in _resourceNames.OrderBy(x => x.FullName))
                {
                    if (ern.AsmLocation.StartsWith(location))
                    {
                        bool exclude = false;
                        foreach (string path in excludePathList)
                        {
                            if (ern.AsmLocation.StartsWith(path))
                                exclude = true;
                        }

                        if (!exclude) retVal.Add(ern.FullName, ern);
                    }
                }
                return retVal;
            }
            catch
            {
                throw;
            }

        }

        private SortedDictionary<string, EmbeddedResourceName> GetResourceFileNameContains(string fileNamePart)
        {
            var retVal = new SortedDictionary<string, EmbeddedResourceName>();
            foreach (EmbeddedResourceName ern in _resourceNames.OrderBy(x => x.FullName))
            {
                if (ern.FileName.Contains(fileNamePart))
                {
                    retVal.Add(ern.FileName, ern);
                }
            }
            return retVal;
        }

        #region UpgradeFileNameComparer class

        private class UpgradeFileNameComparer : IComparer<string>
        {
            #region IComparer<string> Members

            public int Compare(string x, string y)
            {
                return new GeneratedVersion(x).CompareTo(new GeneratedVersion(y));
            }

            #endregion
        }

        #endregion

        #region EmbeddedResourceName class

        private class EmbeddedResourceName
        {
            #region Members

            private string _fullName;
            private string _fileName;
            private string _fileExtension;
            private string _asmLocation;
            private string _asmNamespace;

            #endregion

            #region Constructors

            public EmbeddedResourceName(string fullName)
            {
                string[] splitName = fullName.Split('.');
                _fullName = fullName;
                _fileName = splitName[splitName.Length - 2];
                _fileExtension = splitName[splitName.Length - 1];
                _asmNamespace = DEFAULT_NAMESPACE;
                int namespaceCount = DEFAULT_NAMESPACE.Split('.').Length;
                _asmLocation = string.Empty;
                for (var ii = namespaceCount; ii < splitName.Length; ii++)
                {
                    _asmLocation += "." + splitName[ii];
                }
                _asmLocation.Trim(new char[] { '.' });
            }

            #endregion

            #region Properties

            public string FullName
            {
                get { return _fullName; }
            }

            public string FileName
            {
                get { return _fileName; }
            }

            public string FileExtension
            {
                get { return _fileExtension; }
            }

            public string AsmLocation
            {
                get { return _asmLocation; }
            }

            public string AsmNamespace
            {
                get { return _asmNamespace; }
            }

            #endregion

            public override string ToString()
            {
                return this.FullName;
            }
        }

        #endregion

        public static void LogInfo(string text)
        {
            Log.Information(text);
        }

        public static void LogError(Exception exception, string otherText)
        {
            Log.Error(exception, otherText);
        }

        private string GetFileHash(string name, InstallSetup setup)
        {
            return string.Join("\r\n--GO\r\n", DatabaseServer.ReadSQLFileSectionsFromResource(name, setup)).CalculateMD5Hash();
        }

    }

    #region Version Class

    /// <summary />
    public partial class GeneratedVersion : IComparable<GeneratedVersion>
    {
        #region member variables
        private int _major = 0;
        private int _minor = 0;
        private int _revision = 0;
        private int _build = 0;
        private int _generated = 0;
        private List<int> _extra = new List<int>();
        #endregion

        #region Constructors

        internal GeneratedVersion()
        {
        }

        internal GeneratedVersion(int major, int minor, int revision, int build)
            : this()
        {
            _major = major;
            _minor = minor;
            _revision = revision;
            _build = build;
        }

        /// <summary />
        public GeneratedVersion(int major, int minor, int revision, int build, int generated)
            : this(major, minor, revision, build)
        {
            _generated = generated;
        }

        internal GeneratedVersion(GeneratedVersion version)
            : this()
        {
            _build = version._build;
            _generated = version._generated;
            _major = version._major;
            _minor = version._minor;
            _revision = version._revision;
        }

        internal GeneratedVersion(string[] versionSplit)
            : this()
        {
            if (versionSplit.Length > 0) int.TryParse(versionSplit[0], out _major);
            if (versionSplit.Length > 1) int.TryParse(versionSplit[1], out _minor);
            if (versionSplit.Length > 2) int.TryParse(versionSplit[2], out _revision);
            if (versionSplit.Length > 3) int.TryParse(versionSplit[3], out _build);
            if (versionSplit.Length > 4) int.TryParse(versionSplit[4], out _generated);
        }

        /// <summary>
        /// Determines if the specified string can be parsed as a version
        /// </summary>
        public static bool IsValid(string v)
        {
            if (string.IsNullOrEmpty(v))
                return false;

            var arr1 = v.Split('.');
            if (arr1.Length == 5)
            {
                foreach (var q in arr1)
                {
                    int o;
                    if (!int.TryParse(q, out o))
                        return false;
                }
                return true;
            }
            return false;
        }

        partial void LoadedByFilename(string fileName);

        internal GeneratedVersion(string fileName)
            : this()
        {
            try
            {
                this._extra.Clear();
                if (fileName.Contains("_"))
                {
                    var arr1 = fileName.Split('.');
                    if (arr1.Length >= 1)
                    {
                        string[] versionSplit = null;

                        if (arr1.Length == 1)
                            versionSplit = arr1[0].Split('_');
                        else
                            versionSplit = arr1[arr1.Length - 2].Split('_');

                        if (versionSplit.Length >= 5)
                        {
                            if (versionSplit.Length > 0) int.TryParse(versionSplit[0], out _major);
                            if (versionSplit.Length > 1) int.TryParse(versionSplit[1], out _minor);
                            if (versionSplit.Length > 2) int.TryParse(versionSplit[2], out _revision);
                            if (versionSplit.Length > 3) int.TryParse(versionSplit[3], out _build);
                            if (versionSplit.Length > 4) int.TryParse(versionSplit[4], out _generated);

                            //If there are >5 numbers then save the rest for sorting
                            foreach (var item in versionSplit.Skip(5).ToList())
                            {
                                if (int.TryParse(item, out int v))
                                    this._extra.Add(v);
                                else break;
                            }

                            this.LoadedByFilename(fileName);
                            return;
                        }
                    }
                    _major = -45;
                }
                else
                {
                    var arr1 = fileName.Split('.');
                    if (arr1.Length >= 5)
                    {
                        if (arr1.Length > 0) int.TryParse(arr1[0], out _major);
                        if (arr1.Length > 1) int.TryParse(arr1[1], out _minor);
                        if (arr1.Length > 2) int.TryParse(arr1[2], out _revision);
                        if (arr1.Length > 3) int.TryParse(arr1[3], out _build);
                        if (arr1.Length > 4) int.TryParse(arr1[4], out _generated);

                        //If there are >5 numbers then save the rest for sorting
                        foreach (var item in arr1.Skip(5).ToList())
                        {
                            if (int.TryParse(item, out int v))
                                this._extra.Add(v);
                            else break;
                        }

                        this.LoadedByFilename(fileName);
                    }
                }
            }
            catch
            {
            }
        }

        #endregion

        #region Properties

        /// <summary />
        public int Major
        {
            get { return _major; }
            set { _major = value; }
        }

        /// <summary />
        public int Minor
        {
            get { return _minor; }
            set { _minor = value; }
        }

        /// <summary />
        public int Revision
        {
            get { return _revision; }
            set { _revision = value; }
        }

        /// <summary />
        public int Build
        {
            get { return _build; }
            set { _build = value; }
        }

        /// <summary />
        public int Generated
        {
            get { return _generated; }
            set { _generated = value; }
        }

        #endregion

        #region IComparable<Version> Members

        /// <summary />
        public int CompareTo(GeneratedVersion other)
        {
            if ((object)other == null) return -1;
            if (this.Major != other.Major)
                return this.Major.CompareTo(other.Major);
            else if (this.Minor != other.Minor)
                return this.Minor.CompareTo(other.Minor);
            else if (this.Revision != other.Revision)
                return this.Revision.CompareTo(other.Revision);
            else if (this.Build != other.Build)
                return this.Build.CompareTo(other.Build);
            else if (this.Generated != other.Generated)
                return this.Generated.CompareTo(other.Generated);

            //Check the extra digits in the version if any exist
            var max = System.Math.Max(this._extra.Count, other._extra.Count);
            if (max > 0)
            {
                var l1 = this._extra.ToList();
                var l2 = other._extra.ToList();
                for (var ii = l1.Count; ii < max; ii++) l1.Add(0);
                for (var ii = l2.Count; ii < max; ii++) l2.Add(0);

                for (var ii = 0; ii < max; ii++)
                {
                    if (l1[ii] < l2[ii])
                        return -1;
                    else if (l1[ii] > l2[ii])
                        return 1;
                }
            }

            return 0;
        }

        #endregion

        #region Methods

        /// <summary />
        public override bool Equals(object obj)
        {
            if (!(obj is GeneratedVersion)) return false;
            var v = (GeneratedVersion)obj;
            return (v.Build == this.Build) &&
                (v.Generated == this.Generated) &&
                (v.Major == this.Major) &&
                (v.Minor == this.Minor) &&
                (v.Revision == this.Revision);
        }

        /// <summary />
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        /// <summary />
        public string ToString(string seperationChars)
        {
            var retval = this.Major + seperationChars + this.Minor + seperationChars + this.Revision + seperationChars + this.Build;
            //if (this.Generated != 0) 
            retval += seperationChars + this.Generated;

            var postfix = string.Join(seperationChars, this._extra);
            if (!string.IsNullOrEmpty(postfix)) retval += seperationChars + postfix;

            return retval;
        }

        /// <summary />
        public override string ToString()
        {
            return this.ToString(".");
        }

        #endregion

        #region Operators

        /// <summary />
        public static bool operator <(GeneratedVersion r1, GeneratedVersion r2)
        {
            if (r1 == null && r2 == null) return false;
            if (r1 == null ^ r2 == null) return false;

            if (r1.Major < r2.Major) return true;
            if (r1.Major > r2.Major) return false;

            if (r1.Minor < r2.Minor) return true;
            if (r1.Minor > r2.Minor) return false;

            if (r1.Revision < r2.Revision) return true;
            if (r1.Revision > r2.Revision) return false;

            if (r1.Build < r2.Build) return true;
            if (r1.Build > r2.Build) return false;

            if (r1.Generated < r2.Generated) return true;
            if (r1.Generated > r2.Generated) return false;

            //Check the extra digits in the version if any exist
            var max = System.Math.Max(r1._extra.Count, r2._extra.Count);
            if (max > 0)
            {
                var l1 = r1._extra.ToList();
                var l2 = r2._extra.ToList();
                for (var ii = l1.Count; ii < max; ii++) l1.Add(0);
                for (var ii = l2.Count; ii < max; ii++) l2.Add(0);

                for (var ii = 0; ii < max; ii++)
                {
                    if (l1[ii] < l2[ii])
                        return true;
                    else if (l1[ii] > l2[ii])
                        return false;
                }
            }

            return false;
        }

        /// <summary />
        public static bool operator >(GeneratedVersion r1, GeneratedVersion r2)
        {
            if (r1 == null && r2 == null) return false;
            if (r1 == null ^ r2 == null) return false;

            if ((object)r1 == null && (object)r2 == null) return false;
            if ((object)r1 == null ^ (object)r2 == null) return false;

            if (r1.Major > r2.Major) return true;
            if (r1.Major < r2.Major) return false;

            if (r1.Minor > r2.Minor) return true;
            if (r1.Minor < r2.Minor) return false;

            if (r1.Revision > r2.Revision) return true;
            if (r1.Revision < r2.Revision) return false;

            if (r1.Build > r2.Build) return true;
            if (r1.Build < r2.Build) return false;

            if (r1.Generated > r2.Generated) return true;
            if (r1.Generated < r2.Generated) return false;

            //Check the extra digits in the version if any exist
            var max = System.Math.Max(r1._extra.Count, r2._extra.Count);
            if (max > 0)
            {
                var l1 = r1._extra.ToList();
                var l2 = r2._extra.ToList();
                for (var ii = l1.Count; ii < max; ii++) l1.Add(0);
                for (var ii = l2.Count; ii < max; ii++) l2.Add(0);

                for (var ii = 0; ii < max; ii++)
                {
                    if (l1[ii] < l2[ii])
                        return false;
                    else if (l1[ii] > l2[ii])
                        return true;
                }
            }

            return false;
        }

        /// <summary />
        public static bool operator ==(GeneratedVersion r1, GeneratedVersion r2)
        {
            if ((object)r1 == null && (object)r2 == null) return true;
            if ((object)r1 == null ^ (object)r2 == null) return false;
            if (r1 < r2) return false;
            if (r1 > r2) return false;
            return true;
        }

        /// <summary />
        public static bool operator !=(GeneratedVersion r1, GeneratedVersion r2)
        {
            return !(r1 == r2);
        }

        #endregion

    }
    #endregion

    #region EncryptionLibrary

    /// <summary />
    public partial class EncryptionLibrary
    {
        /// <summary>
        /// Override this method to implement your own hashing algorithm
        /// </summary>
        /// <param name="input">The input string to hash</param>
        /// <param name="output">Set this parameter to a string with 1 or more characters to override the default hashing algorithm</param>
        /// <returns></returns>
        partial void HashOverride(string input, ref string output);

        /// <summary />
        public string Hash(string input)
        {
            string output = string.Empty;
            HashOverride(input, ref output);
            if (!string.IsNullOrEmpty(output)) return output;
            return CalculateMD5(input);
        }

        private string CalculateMD5(string input)
        {
            // step 1, calculate MD5 hash from input
            var inputBytes = System.Text.Encoding.ASCII.GetBytes(input);
            var hash = MD5Provider.ComputeHash(inputBytes);

            // step 2, convert byte array to hex string
            var sb = new StringBuilder();
            for (var i = 0; i < hash.Length; i++)
            {
                sb.Append(hash[i].ToString("X2"));
            }
            return sb.ToString();
        }
    }

    #endregion

    #region MD5
    // Simple struct for the (a,b,c,d) which is used to compute the mesage digest.    
    internal struct ABCDStruct
    {
        public uint A;
        public uint B;
        public uint C;
        public uint D;
    }

    /// <summary />
    public static class MD5Provider
    {
        /// <summary />
        public static byte[] ComputeHash(byte[] input)
        {
            return ComputeHash(input, 0, input.Length);
        }

        /// <summary />
        public static byte[] ComputeHash(byte[] input, int startIndex, int length)
        {
            if (null == input)
                throw new System.ArgumentNullException("input", "Unable to calculate hash over null input data");

            //Intitial values defined in RFC 1321
            ABCDStruct abcd;// = new ABCDStruct();
            abcd.A = 0x67452301;
            abcd.B = 0xefcdab89;
            abcd.C = 0x98badcfe;
            abcd.D = 0x10325476;

            //We pass in the input array by block, the final block of data must be handled specialy for padding & length embeding
            while (startIndex <= length - 64)
            {
                MD5Provider.ComputeHashBlock(input, ref abcd, startIndex);
                startIndex += 64;
            }
            // The final data block. 
            return MD5Provider.ComputeHashFinalBlock(input, startIndex, length - startIndex, abcd, (Int64)length * 8);
        }

        /// <summary />
        internal static byte[] ComputeHashFinalBlock(byte[] input, int ibStart, int cbSize, ABCDStruct ABCD, Int64 len)
        {
            var working = new byte[64];
            var length = BitConverter.GetBytes(len);

            //Padding is a single bit 1, followed by the number of 0s required to make size congruent to 448 modulo 512. Step 1 of RFC 1321  
            //The CLR ensures that our buffer is 0-assigned, we don't need to explicitly set it. This is why it ends up being quicker to just
            //use a temporary array rather then doing in-place assignment (5% for small inputs)
            Array.Copy(input, ibStart, working, 0, cbSize);
            working[cbSize] = 0x80;

            //We have enough room to store the length in this chunk
            if (cbSize < 56)
            {
                Array.Copy(length, 0, working, 56, 8);
                ComputeHashBlock(working, ref ABCD, 0);
            }
            else  //We need an aditional chunk to store the length
            {
                ComputeHashBlock(working, ref ABCD, 0);
                //Create an entirely new chunk due to the 0-assigned trick mentioned above, to avoid an extra function call clearing the array
                working = new byte[64];
                Array.Copy(length, 0, working, 56, 8);
                ComputeHashBlock(working, ref ABCD, 0);
            }
            byte[] output = new byte[16];
            Array.Copy(BitConverter.GetBytes(ABCD.A), 0, output, 0, 4);
            Array.Copy(BitConverter.GetBytes(ABCD.B), 0, output, 4, 4);
            Array.Copy(BitConverter.GetBytes(ABCD.C), 0, output, 8, 4);
            Array.Copy(BitConverter.GetBytes(ABCD.D), 0, output, 12, 4);
            return output;
        }

        // Performs a single block transform of MD5 for a given set of ABCD inputs
        /* If implementing your own hashing framework, be sure to set the initial ABCD correctly according to RFC 1321:
        //    A = 0x67452301;
        //    B = 0xefcdab89;
        //    C = 0x98badcfe;
        //    D = 0x10325476;
        */
        /// <summary />
        internal static void ComputeHashBlock(byte[] input, ref ABCDStruct ABCDValue, int ibStart)
        {
            uint[] temp = Converter(input, ibStart);
            uint a = ABCDValue.A;
            uint b = ABCDValue.B;
            uint c = ABCDValue.C;
            uint d = ABCDValue.D;

            a = r1(a, b, c, d, temp[0], 7, 0xd76aa478);
            d = r1(d, a, b, c, temp[1], 12, 0xe8c7b756);
            c = r1(c, d, a, b, temp[2], 17, 0x242070db);
            b = r1(b, c, d, a, temp[3], 22, 0xc1bdceee);
            a = r1(a, b, c, d, temp[4], 7, 0xf57c0faf);
            d = r1(d, a, b, c, temp[5], 12, 0x4787c62a);
            c = r1(c, d, a, b, temp[6], 17, 0xa8304613);
            b = r1(b, c, d, a, temp[7], 22, 0xfd469501);
            a = r1(a, b, c, d, temp[8], 7, 0x698098d8);
            d = r1(d, a, b, c, temp[9], 12, 0x8b44f7af);
            c = r1(c, d, a, b, temp[10], 17, 0xffff5bb1);
            b = r1(b, c, d, a, temp[11], 22, 0x895cd7be);
            a = r1(a, b, c, d, temp[12], 7, 0x6b901122);
            d = r1(d, a, b, c, temp[13], 12, 0xfd987193);
            c = r1(c, d, a, b, temp[14], 17, 0xa679438e);
            b = r1(b, c, d, a, temp[15], 22, 0x49b40821);

            a = r2(a, b, c, d, temp[1], 5, 0xf61e2562);
            d = r2(d, a, b, c, temp[6], 9, 0xc040b340);
            c = r2(c, d, a, b, temp[11], 14, 0x265e5a51);
            b = r2(b, c, d, a, temp[0], 20, 0xe9b6c7aa);
            a = r2(a, b, c, d, temp[5], 5, 0xd62f105d);
            d = r2(d, a, b, c, temp[10], 9, 0x02441453);
            c = r2(c, d, a, b, temp[15], 14, 0xd8a1e681);
            b = r2(b, c, d, a, temp[4], 20, 0xe7d3fbc8);
            a = r2(a, b, c, d, temp[9], 5, 0x21e1cde6);
            d = r2(d, a, b, c, temp[14], 9, 0xc33707d6);
            c = r2(c, d, a, b, temp[3], 14, 0xf4d50d87);
            b = r2(b, c, d, a, temp[8], 20, 0x455a14ed);
            a = r2(a, b, c, d, temp[13], 5, 0xa9e3e905);
            d = r2(d, a, b, c, temp[2], 9, 0xfcefa3f8);
            c = r2(c, d, a, b, temp[7], 14, 0x676f02d9);
            b = r2(b, c, d, a, temp[12], 20, 0x8d2a4c8a);

            a = r3(a, b, c, d, temp[5], 4, 0xfffa3942);
            d = r3(d, a, b, c, temp[8], 11, 0x8771f681);
            c = r3(c, d, a, b, temp[11], 16, 0x6d9d6122);
            b = r3(b, c, d, a, temp[14], 23, 0xfde5380c);
            a = r3(a, b, c, d, temp[1], 4, 0xa4beea44);
            d = r3(d, a, b, c, temp[4], 11, 0x4bdecfa9);
            c = r3(c, d, a, b, temp[7], 16, 0xf6bb4b60);
            b = r3(b, c, d, a, temp[10], 23, 0xbebfbc70);
            a = r3(a, b, c, d, temp[13], 4, 0x289b7ec6);
            d = r3(d, a, b, c, temp[0], 11, 0xeaa127fa);
            c = r3(c, d, a, b, temp[3], 16, 0xd4ef3085);
            b = r3(b, c, d, a, temp[6], 23, 0x04881d05);
            a = r3(a, b, c, d, temp[9], 4, 0xd9d4d039);
            d = r3(d, a, b, c, temp[12], 11, 0xe6db99e5);
            c = r3(c, d, a, b, temp[15], 16, 0x1fa27cf8);
            b = r3(b, c, d, a, temp[2], 23, 0xc4ac5665);

            a = r4(a, b, c, d, temp[0], 6, 0xf4292244);
            d = r4(d, a, b, c, temp[7], 10, 0x432aff97);
            c = r4(c, d, a, b, temp[14], 15, 0xab9423a7);
            b = r4(b, c, d, a, temp[5], 21, 0xfc93a039);
            a = r4(a, b, c, d, temp[12], 6, 0x655b59c3);
            d = r4(d, a, b, c, temp[3], 10, 0x8f0ccc92);
            c = r4(c, d, a, b, temp[10], 15, 0xffeff47d);
            b = r4(b, c, d, a, temp[1], 21, 0x85845dd1);
            a = r4(a, b, c, d, temp[8], 6, 0x6fa87e4f);
            d = r4(d, a, b, c, temp[15], 10, 0xfe2ce6e0);
            c = r4(c, d, a, b, temp[6], 15, 0xa3014314);
            b = r4(b, c, d, a, temp[13], 21, 0x4e0811a1);
            a = r4(a, b, c, d, temp[4], 6, 0xf7537e82);
            d = r4(d, a, b, c, temp[11], 10, 0xbd3af235);
            c = r4(c, d, a, b, temp[2], 15, 0x2ad7d2bb);
            b = r4(b, c, d, a, temp[9], 21, 0xeb86d391);

            ABCDValue.A = unchecked(a + ABCDValue.A);
            ABCDValue.B = unchecked(b + ABCDValue.B);
            ABCDValue.C = unchecked(c + ABCDValue.C);
            ABCDValue.D = unchecked(d + ABCDValue.D);
            return;
        }

        //Manually unrolling these equations nets us a 20% performance improvement
        private static uint r1(uint a, uint b, uint c, uint d, uint x, int s, uint t)
        {
            //                  (b + LSR((a + F(b, c, d) + x + t), s))
            //F(x, y, z)        ((x & y) | ((x ^ 0xFFFFFFFF) & z))
            return unchecked(b + LSR((a + ((b & c) | ((b ^ 0xFFFFFFFF) & d)) + x + t), s));
        }

        private static uint r2(uint a, uint b, uint c, uint d, uint x, int s, uint t)
        {
            //                  (b + LSR((a + G(b, c, d) + x + t), s))
            //G(x, y, z)        ((x & z) | (y & (z ^ 0xFFFFFFFF)))
            return unchecked(b + LSR((a + ((b & d) | (c & (d ^ 0xFFFFFFFF))) + x + t), s));
        }

        private static uint r3(uint a, uint b, uint c, uint d, uint x, int s, uint t)
        {
            //                  (b + LSR((a + H(b, c, d) + k + i), s))
            //H(x, y, z)        (x ^ y ^ z)
            return unchecked(b + LSR((a + (b ^ c ^ d) + x + t), s));
        }

        private static uint r4(uint a, uint b, uint c, uint d, uint x, int s, uint t)
        {
            //                  (b + LSR((a + I(b, c, d) + k + i), s))
            //I(x, y, z)        (y ^ (x | (z ^ 0xFFFFFFFF)))
            return unchecked(b + LSR((a + (c ^ (b | (d ^ 0xFFFFFFFF))) + x + t), s));
        }

        // Implementation of left rotate
        // s is an int instead of a uint becuase the CLR requires the argument passed to >>/<< is of 
        // type int. Doing the demoting inside this function would add overhead.
        private static uint LSR(uint i, int s)
        {
            return ((i << s) | (i >> (32 - s)));
        }

        //Convert input array into array of UInts
        private static uint[] Converter(byte[] input, int ibStart)
        {
            if (null == input)
                throw new System.ArgumentNullException("input", "Unable convert null array to array of uInts");

            uint[] result = new uint[16];

            for (int i = 0; i < 16; i++)
            {
                result[i] = (uint)input[ibStart + i * 4];
                result[i] += (uint)input[ibStart + i * 4 + 1] << 8;
                result[i] += (uint)input[ibStart + i * 4 + 2] << 16;
                result[i] += (uint)input[ibStart + i * 4 + 3] << 24;
            }

            return result;
        }
    }
    #endregion

    #region Extensions

    /// <summary />
    internal static class Extensions
    {
        /// <summary />
        internal static List<string> BreakLines(this string text)
        {
            if (string.IsNullOrEmpty(text)) return new List<string>();
            return text.Replace("\x01", string.Empty)
                .Replace("\r\n", "\n") //convert all Windows to Linux endings
                .Split('\n', StringSplitOptions.None) //split on Linux endings
                .ToList();
        }

        /// <summary />
        internal static List<string> TrimAll(this IEnumerable<string> strArray)
        {
            var retval = new List<string>();
            foreach (var s in strArray)
                retval.Add(s.Trim().Trim(new char[] { '\t', ' ' }).Trim());
            return retval;
        }

        /// <summary />
        public static string CalculateMD5Hash(this string input)
        {
            var q = new EncryptionLibrary();
            return q.Hash(input);
        }

        private static readonly string CryptKey = "8s$w@r1%a-m>2pq9";
        private static readonly string IVKey = "@2C1c3D4e5F6g7H8";

        /// <summary />
        public static string Encrypt(this string text)
        {
            try
            {
                var aes = new AesCryptoServiceProvider();
                aes.BlockSize = 128;
                aes.KeySize = 128;
                aes.IV = Encoding.UTF8.GetBytes(IVKey);
                aes.Key = Encoding.UTF8.GetBytes(CryptKey);
                aes.Mode = CipherMode.CBC;
                aes.Padding = PaddingMode.PKCS7;

                // Convert string to byte array
                byte[] src = Encoding.Unicode.GetBytes(text);

                // encryption
                using (ICryptoTransform encrypt = aes.CreateEncryptor())
                {
                    byte[] dest = encrypt.TransformFinalBlock(src, 0, src.Length);

                    // Convert byte array to Base64 strings
                    return Convert.ToBase64String(dest);
                }
            }
            catch (Exception ex)
            {
                return null;
            }
        }

        /// <summary />
        public static string Decrypt(this string text)
        {
            try
            {
                var aes = new AesCryptoServiceProvider();
                aes.BlockSize = 128;
                aes.KeySize = 128;
                aes.IV = Encoding.UTF8.GetBytes(IVKey);
                aes.Key = Encoding.UTF8.GetBytes(CryptKey);
                aes.Mode = CipherMode.CBC;
                aes.Padding = PaddingMode.PKCS7;

                // Convert Base64 strings to byte array
                byte[] src = System.Convert.FromBase64String(text);

                // decryption
                using (ICryptoTransform decrypt = aes.CreateDecryptor())
                {
                    byte[] dest = decrypt.TransformFinalBlock(src, 0, src.Length);
                    return Encoding.Unicode.GetString(dest);
                }

            }
            catch (Exception ex)
            {
                return null;
            }
        }

        /// <summary />
        public static string FormattedTime(this System.Diagnostics.Stopwatch timer)
        {
            return timer.Elapsed.ToString(@"hh\:mm\:ss");
        }

        /// <summary />
        public static string StripResourceAssem(string resource)
        {
            var orig = resource;
            try
            {
                var fi = new FileInfo(System.Reflection.Assembly.GetExecutingAssembly().Location);
                var s1 = fi.Directory.FullName;
                var s2 = System.Reflection.Assembly.GetExecutingAssembly().GetName().Name;
                resource = resource.Replace(s1, string.Empty);
                if (resource.StartsWith(s2))
                    resource = resource.Substring(s2.Length + 1, resource.Length - s2.Length - 1);
                return resource;
            }
            catch (Exception ex)
            {
                return orig;
            }
        }

    }
    #endregion

}
#pragma warning restore 0168
