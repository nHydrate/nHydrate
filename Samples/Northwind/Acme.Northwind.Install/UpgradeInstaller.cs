//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable 0168
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Security.Cryptography;
using System.IO;

namespace Acme.Northwind.Install
{
	/// <summary>
	/// Provides installation functionality for databases
	/// </summary>
	internal class UpgradeInstaller
	{
		#region member variables

		internal static readonly GeneratedVersion _def_Version = new GeneratedVersion(-1, -1, -1, -1, -1);

		internal const string DEFAULT_NAMESPACE = "Acme.Northwind.Install";
		internal const string MODELKEY = "1aeb9949-ba47-477b-bfdf-c06fe5872e85";
		private GeneratedVersion _previousVersion = null;
		private static GeneratedVersion _upgradeToVersion = new GeneratedVersion(0, 0, 0, 0, 5);
		private InstallSetup _setup = null;
		private System.Data.SqlClient.SqlConnection _connection;
		private System.Data.SqlClient.SqlTransaction _transaction;
		private List<EmbeddedResourceName> _resourceNames = new List<EmbeddedResourceName>();
		private List<nHydrateDbObject> _databaseItems = new List<nHydrateDbObject>();
		private List<nHydrateDbObject> _currentItems = new List<nHydrateDbObject>();

		#endregion

		private static GeneratedVersion UpgradeToVersion
		{
			get { return UpgradeInstaller._upgradeToVersion; }
		}

		/// <summary>
		/// Upgrades a database to the newest schema
		/// </summary>
		public static void UpgradeDatabase(InstallSetup setup)
		{
			#region Verify that the database can be opened
			//Try this 10 times and then fail
			var isError = true;
			while (isError)
			{
				try
				{
					var settings = new nHydrateSetting();
					settings.Load(setup.ConnectionString);
					isError = false;
				}
				catch (Exception ex)
				{
					System.Threading.Thread.Sleep(500);
					isError = true;
				}
			}
			#endregion

			try
			{
				var upgradeInstaller = new UpgradeInstaller(setup);
				upgradeInstaller.Initialize();
				upgradeInstaller.RunUpgrade(setup);
			}
			catch (Exception ex) { throw; }
		}

		public static void AzureCopyDatabase(InstallSettings settings)
		{
			var o = new AzureCopy();
			o.Run(settings);
		}

		#region construct / initialize

		private UpgradeInstaller(InstallSetup setup)
		{
			if (setup == null)
				throw new Exception("The setup object cannot be null.");

			if (setup.Version == null)
				_previousVersion = new GeneratedVersion(_def_Version);
			else
				_previousVersion = setup.Version;
			_setup = setup;
		}

		private void Initialize()
		{
			var settings = new nHydrateSetting();
			if (_setup.Version == null)
			{
				settings.Load(_setup.ConnectionString);
			}
			else
			{
				settings.dbVersion = _setup.Version.ToString();
				settings.ModelKey = new Guid(MODELKEY);
			}

			//Verify that this is the proper database for this model, if there is a previous key
			if (settings.ModelKey != Guid.Empty)
			{
				if (settings.ModelKey != new Guid(MODELKEY))
				{
					if (System.Windows.Forms.MessageBox.Show("The database being updated was created against a different model. This may cause database versioning issues if you continue.\n\nDo you wish to continue?", "Continue?", System.Windows.Forms.MessageBoxButtons.YesNo, System.Windows.Forms.MessageBoxIcon.Warning) != System.Windows.Forms.DialogResult.Yes)
					{
						return;
					}
				}
			}

			if (settings.dbVersion != string.Empty)
			{
				string[] versionNumbers = settings.dbVersion.Split('.');
				_previousVersion = new GeneratedVersion();
				_previousVersion.Major = int.Parse(versionNumbers[0]);
				_previousVersion.Minor = int.Parse(versionNumbers[1]);
				_previousVersion.Revision = int.Parse(versionNumbers[2]);
				_previousVersion.Build = int.Parse(versionNumbers[3]);
				if (versionNumbers.Length >= 5)
					_previousVersion.Generated = int.Parse(versionNumbers[4]);
			}
			var assem = Assembly.GetExecutingAssembly();
			var resourceNames = assem.GetManifestResourceNames();
			foreach (string resourceName in resourceNames)
			{
				var ern = new EmbeddedResourceName(resourceName);
				_resourceNames.Add(ern);
			}
		}

		#endregion

		public static string GetUpgradeScript(InstallSetup setup)
		{
			var upgradeInstaller = new UpgradeInstaller(setup);
			upgradeInstaller.Initialize();
			var sb = new StringBuilder();
			upgradeInstaller.UpgradeFolder1(sb, setup.SkipSections);
			upgradeInstaller.UpgradeFolder2(sb, setup);
			upgradeInstaller.UpgradeFolder3(sb, setup.SkipSections);
			upgradeInstaller.UpgradeFolder4(sb, setup.SkipSections);
			upgradeInstaller.UpgradeFolder5(sb, setup.SkipSections);
			upgradeInstaller.UpgradeFolder6(sb, setup.SkipSections);

			var settings = new nHydrateSetting();
			settings.dbVersion = UpgradeInstaller.UpgradeToVersion.ToString(".");
			settings.LastUpdate = DateTime.Now;
			settings.ModelKey = new Guid(MODELKEY);
			settings.History.Add(new HistoryItem() { Version = UpgradeInstaller.UpgradeToVersion.ToString("."), PublishDate = DateTime.Now });
			sb.AppendLine(settings.GetVersionUpdateScript());

			return sb.ToString();
		}

		public static bool NeedsUpdate(string connectionString)
		{
			var settings = new nHydrateSetting();
			settings.Load(connectionString);
			if (!settings.IsLoaded) return true; //Cannot find version so upgrade

			var currentDbVersion = _def_Version;
			if (!string.IsNullOrEmpty(settings.dbVersion))
				currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));
			else
				return true;

			return (currentDbVersion < UpgradeInstaller.UpgradeToVersion);
		}

		public static string VersionInstalled(string connectionString)
		{
			var settings = new nHydrateSetting();
			settings.Load(connectionString);
			var currentDbVersion = _def_Version;
			if (settings.IsLoaded)
			{
				if (!string.IsNullOrEmpty(settings.dbVersion))
					currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));
			}
			return currentDbVersion.ToString();
		}

		public static string VersionLatest()
		{
			return _upgradeToVersion.ToString();
		}

		public static bool IsVersioned(string connectionString)
		{
			var settings = new nHydrateSetting();
			settings.Load(connectionString);
			var currentDbVersion = _def_Version;
			if (settings.IsLoaded)
			{
				if (!string.IsNullOrEmpty(settings.dbVersion))
					currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));
			}
			return (currentDbVersion != _def_Version);
		}

		private void RunUpgrade(InstallSetup setup)
		{
			if (setup.Transaction == null || !setup.UseTransaction)
			{
				_connection = new System.Data.SqlClient.SqlConnection(setup.ConnectionString);
				_connection.Open();
				if (setup.UseTransaction)
					_transaction = _connection.BeginTransaction(System.Data.IsolationLevel.RepeatableRead);
			}
			else //transaction is NOT null AND UseTransaction is TRUE
			{
				_connection = setup.Transaction.Connection;
				_transaction = setup.Transaction;
			}

			//If this is a create then skip some unnecessary script sections
			if (setup.InstallStatus == InstallStatusConstants.Create && setup.SkipSections == null)
			{
				var skipSections = new List<string>();
				skipSections.Add("FIELD CREATE");
				skipSections.Add("AUDIT TRAIL REMOVE");
				skipSections.Add("RENAME PK");
				skipSections.Add("DROP PK");
				skipSections.Add("REMOVE DEFAULTS");
				setup.SkipSections = skipSections;
			}

			_databaseItems = nHydrateDbObject.Load(setup.ConnectionString, MODELKEY, _transaction);

			try
			{
				var settings = new nHydrateSetting();
				settings.Load(setup.ConnectionString);

				var currentDbVersion = _def_Version;
				if (!string.IsNullOrEmpty(settings.dbVersion))
					currentDbVersion = new GeneratedVersion(settings.dbVersion.Split('.'));

				if (currentDbVersion > _upgradeToVersion)
				{
					System.Windows.Forms.MessageBox.Show("The current database version (" + currentDbVersion.ToString() + ") is greater than the current library (" + _upgradeToVersion.ToString() + "). The upgrade will not proceed.", "Error", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Error);
					return;
				}

				#region 1_UserDefinedInitialization
				this.UpgradeFolder1(setup.SkipSections);
				#endregion

				#region 2_Upgrade Scripts
				this.UpgradeFolder2(setup);
				#endregion

				#region 3_GeneratedTablesAndData
				this.UpgradeFolder3(setup.SkipSections);
				#endregion

				#region 4_UserDefinedPostTablesAndData
				this.UpgradeFolder4(setup.SkipSections);
				#endregion

				#region 5_Programmability
				UpgradeFolder5(setup.SkipSections);
				#endregion

				#region 6_UserDefinedFinalize
				UpgradeFolder6(setup.SkipSections);
				#endregion

				nHydrateDbObject.Save(setup.ConnectionString, MODELKEY, _currentItems, _transaction);

				//Do not commit if external transaction
				if (_transaction != null)
					_transaction.Commit();

				settings.dbVersion = _upgradeToVersion.ToString(".");
				settings.LastUpdate = DateTime.Now;
				settings.ModelKey = new Guid(MODELKEY);
				settings.History.Add(new HistoryItem() { Version = _upgradeToVersion.ToString("."), PublishDate = DateTime.Now });
				settings.Save(setup.ConnectionString);

				SqlServers.DeleteExtendedProperty(setup.ConnectionString, "dbVersion");
				SqlServers.DeleteExtendedProperty(setup.ConnectionString, "LastUpdate");
				SqlServers.DeleteExtendedProperty(setup.ConnectionString, "ModelKey");
				SqlServers.DeleteExtendedProperty(setup.ConnectionString, "History");
			}
			catch (InvalidSQLException ex)
			{
				var F = new SqlErrorForm();
				F.Setup(ex);
				F.ShowDialog();
				if (_transaction == null)
					_transaction.Rollback();
				throw ex;
			}
			catch (Exception ex)
			{
				System.Windows.Forms.MessageBox.Show(ex.Message, "Error!", System.Windows.Forms.MessageBoxButtons.OK, System.Windows.Forms.MessageBoxIcon.Error);
				if (_transaction == null)
					_transaction.Rollback();
				throw;
			}
			finally
			{
				_connection.Close();
			}

		}

		private void AppendCleanScript(IEnumerable<string> scripts, StringBuilder sb)
		{
			foreach (var s in scripts)
				AppendCleanScript(s, sb);
		}

		private void AppendCleanScript(string script, StringBuilder sb)
		{
			if (string.IsNullOrEmpty(script)) return;
			var lines = script.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);
			foreach (var s in lines)
			{
				if (!s.StartsWith("--MODELID"))
					sb.AppendLine(s);
			}
			sb.AppendLine("GO");
		}

		private void UpgradeFolder1(IEnumerable<string> skipSections)
		{
			UpgradeFolder1(null, skipSections);
		}

		private void UpgradeFolder1(StringBuilder sb, IEnumerable<string> skipSections)
		{
			const string MAIN_FOLDER = "._1_UserDefinedInitialization.";
			const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
			const string NEWDATABASE_FOLDER = MAIN_FOLDER + "NewDatabase";
			const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
			const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

			if (_setup.NewInstall) //NEW DATABASE
			{
				var scripts = this.GetResourceNameUnderLocation(NEWDATABASE_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else //VERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

			//RUN ALWAYS
			{
				var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

		}

		private void UpgradeFolder2(InstallSetup setup)
		{
			UpgradeFolder2(null, setup);
		}

		private void UpgradeFolder2(StringBuilder sb, InstallSetup setup)
		{
			if (setup.NewInstall) return;

			const string UPGRADE_GENERATED_FOLDER = "._2_Upgrade_Scripts.";
			var upgradeSchemaScripts = this.GetResourceNameUnderLocation(UPGRADE_GENERATED_FOLDER);
			var sortByVersionScripts = new SortedDictionary<string, EmbeddedResourceName>(upgradeSchemaScripts, new UpgradeFileNameComparer());

			//Run the generated upgrades
			foreach (EmbeddedResourceName ern in sortByVersionScripts.Values)
			{
				if (new GeneratedVersion(ern.FileName).CompareTo(_previousVersion) > 0)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, null, setup.SkipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, setup.SkipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
		}

		private void UpgradeFolder3(IEnumerable<string> skipSections)
		{
			UpgradeFolder3(null, skipSections);
		}

		private void UpgradeFolder3(StringBuilder sb, IEnumerable<string> skipSections)
		{
			const string MAIN_FOLDER = "._3_GeneratedTablesAndData.";
			const string CREATE_SCHEMA_FILE = MAIN_FOLDER + "CreateSchema.sql";
			const string TRIGGER_FILE = MAIN_FOLDER + "CreateSchemaAuditTriggers.sql";
			const string STATIC_DATA_FILE = MAIN_FOLDER + "CreateData.sql";

			//Do not run installation scripts if versions match
			//if (_previousVersion.Equals(_upgradeToVersion))
			//	return;

			try
			{
				//Run the create schema
				var scripts = this.GetResourceNameUnderLocation(CREATE_SCHEMA_FILE);
				foreach (EmbeddedResourceName ern in scripts.Values)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}

				//Run the static data
				scripts = this.GetResourceNameUnderLocation(STATIC_DATA_FILE);
				foreach (var ern in scripts.Values)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}

				//Run the triggers
				scripts = this.GetResourceNameUnderLocation(TRIGGER_FILE);
				foreach (var ern in scripts.Values)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			catch (Exception ex) { throw; }
		}

		private void UpgradeFolder4(IEnumerable<string> skipSections)
		{
			UpgradeFolder4(null, skipSections);
		}

		private void UpgradeFolder4(StringBuilder sb, IEnumerable<string> skipSections)
		{
			const string MAIN_FOLDER = "._4_UserDefinedPostTablesAndData.";
			const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
			const string NEWDATABASE_FOLDER = MAIN_FOLDER + "NewDatabase";
			const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
			const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

			if (_setup.NewInstall) //NEW DATABASE
			{
				var scripts = this.GetResourceNameUnderLocation(NEWDATABASE_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else //VERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

			//RUN ALWAYS
			{
				var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

		}

		private void UpgradeFolder5(IEnumerable<string> skipSections)
		{
			UpgradeFolder5(null, skipSections);
		}

		/// <summary>
		/// Run Model/User-Defined Scripts from Programmability
		/// </summary>
		private void UpgradeFolder5(StringBuilder sb, IEnumerable<string> skipSections)
		{
			const string MAIN_FOLDER = "._5_Programmability.";

			//Run user-defined objects and get determine an order for them if necessary (on failure)
			var failedScripts = new List<KeyValuePair<Guid, string>>();
			var successOrderScripts = new List<Guid>();

			//User-defined (Manually Added)
			var alluserDefinedScripts = GetUserDefinedScripts(MAIN_FOLDER + "Stored_Procedures.User_Defined", skipSections);
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Views.User_Defined", skipSections)).ToDictionary(x => x.Key, x => x.Value);
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Functions.User_Defined", skipSections)).ToDictionary(x => x.Key, x => x.Value);

			//Model (managed)
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Stored_Procedures.Model", skipSections)).ToDictionary(x => x.Key, x => x.Value);
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Views.Model", skipSections)).ToDictionary(x => x.Key, x => x.Value);
			alluserDefinedScripts = alluserDefinedScripts.Concat(GetUserDefinedScripts(MAIN_FOLDER + "Functions.Model", skipSections)).ToDictionary(x => x.Key, x => x.Value);

			if (sb == null)
			{
				this.ReinstallUserDefinedScripts(this.ReorderScripts(alluserDefinedScripts), failedScripts, successOrderScripts, _databaseItems, _currentItems);
				this.RunErrors(failedScripts, successOrderScripts);
			}
			else
			{
				this.ReorderScripts(alluserDefinedScripts).ForEach(x => AppendCleanScript(x.Value, sb));
			}

			//Run internal objects last. They should always work
			this.ReinstallStoredProceduresInternal(null, sb);
		}

		private void UpgradeFolder6(IEnumerable<string> skipSections)
		{
			UpgradeFolder6(null, skipSections);
		}

		private void UpgradeFolder6(StringBuilder sb, IEnumerable<string> skipSections)
		{
			const string MAIN_FOLDER = "._6_UserDefinedFinalize.";
			const string ALWAYS_FOLDER = MAIN_FOLDER + "Always";
			const string NEWDATABASE_FOLDER = MAIN_FOLDER + "NewDatabase";
			const string UNVERSIONED_FOLDER = MAIN_FOLDER + "UnVersioned";
			const string VERSIONED_FOLDER = MAIN_FOLDER + "Versioned";

			if (_setup.NewInstall) //NEW DATABASE
			{
				var scripts = this.GetResourceNameUnderLocation(NEWDATABASE_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else if (_def_Version.Equals(_previousVersion)) //UNVERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(UNVERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}
			else //VERSIONED
			{
				var scripts = this.GetResourceNameUnderLocation(VERSIONED_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

			//RUN ALWAYS
			{
				var scripts = this.GetResourceNameUnderLocation(ALWAYS_FOLDER);
				foreach (var file in scripts.Keys)
				{
					if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, file, null, null, skipSections, _databaseItems, _currentItems);
					else SqlServers.ReadSQLFileSectionsFromResource(file, skipSections).ToList().ForEach(s => AppendCleanScript(s, sb));
				}
			}

		}

		private void RunErrors(List<KeyValuePair<Guid, string>> failedScripts)
		{
			RunErrors(failedScripts, null);
		}

		private void RunErrors(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts)
		{
			if (failedScripts.Count == 0) return;
			var runFailed = true;
			do
			{
				var _scripts2 = new List<KeyValuePair<Guid, string>>();
				foreach (var item in failedScripts)
				{
					var key = item.Key;
					var sql = item.Value;
					SqlServers.ExecuteSQL(_connection, _transaction, sql, _scripts2, successOrderScripts);
				}
				runFailed = (_scripts2.Count < failedScripts.Count && _scripts2.Count > 0);
				failedScripts = _scripts2;
			} while (runFailed);

			if (failedScripts.Count > 0)
			{
				//This will throw a proper error
				SqlServers.ExecuteSQL(_connection, _transaction, failedScripts.First().Value);
				//Use this for debugging if necessary
				var sql = string.Join("\r\n\r\nGO\r\n--SCRIPT BREAK\r\n\r\n", failedScripts.Select(x => x.Value));
			}
			else if (successOrderScripts != null)
			{
				//Only do this in debug
#if (DEBUG)
				if (System.Diagnostics.Debugger.IsAttached)
				{
					var nOrderFile = System.IO.Path.Combine(new System.IO.FileInfo(System.Reflection.Assembly.GetExecutingAssembly().Location).DirectoryName, "installer.norder");
					//If there are no failures then ensure that there is no "norder" file
					if (System.IO.File.Exists(nOrderFile))
						System.IO.File.Delete(nOrderFile);

					//On success, write the XML file with the proper order
					try
					{
						var document = new System.Xml.XmlDocument();
						document.LoadXml("<root type=\"installer\"></root>");
						document.DocumentElement.AppendChild(document.CreateWhitespace("\r\n"));
						foreach (var k in successOrderScripts)
						{
							document.DocumentElement.AddElement("key", k.ToString());
							document.DocumentElement.AppendChild(document.CreateWhitespace("\r\n"));
						}
						document.Save(nOrderFile);
					}
					catch (Exception ex)
					{
					}
				}
#endif
			}
		}

		#region Get Internal Objects

		private void ReinstallStoredProceduresInternal(List<KeyValuePair<Guid, string>> failedScripts, StringBuilder sb)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation("._5_Programmability.Stored_Procedures.Internal");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						if (sb == null) SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, _databaseItems, _currentItems);
						else SqlServers.ReadSQLFileSectionsFromResource(ern.FullName, null).ToList().ForEach(s => AppendCleanScript(s, sb));
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch { throw; }
		}

		#endregion

		#region Get User-Defined Objects

		private Dictionary<string, List<string>> GetUserDefinedScripts(string subFolder, IEnumerable<string> skipSections)
		{
			try
			{
				var retval = new Dictionary<string, List<string>>();
				var storedProcedures = this.GetResourceNameUnderLocation(subFolder);
				foreach (var ern in storedProcedures.Values)
				{
					try
					{
						//Skip Internal
						if (!ern.FullName.Contains(subFolder + ".Internal"))
							retval.Add(ern.FullName, SqlServers.GetEmbeddedScripts(ern.FullName, skipSections));
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
				return retval;
			}
			catch { throw; }
		}

		private List<KeyValuePair<string, string>> ReorderScripts(Dictionary<string, List<string>> allScripts)
		{
			var l = this.GetResourceNameUnderLocation("._5_Programmability.ScriptOrder.nOrder");
			var reorderedScripts = new Dictionary<string, List<string>>();
			var retval = new List<KeyValuePair<string, string>>();

			#region Create an unordered flat list
			var flatList = new List<KeyValuePair<string, string>>();
			foreach (var k in allScripts.Keys)
			{
				foreach (var v in allScripts[k])
				{
					flatList.Add(new KeyValuePair<string, string>(k, v));
				}
			}
			#endregion

			if (l.Values.Count > 0)
			{
				var xml = SqlServers.GetEmbeddedResource(l.Values.First().FullName);
				var document = new XmlDocument();
				try
				{
					//Load the ordered key list
					document.LoadXml(xml);

					//Loop throu ordered key list and put scripts in order
					foreach (XmlNode n in document.DocumentElement.ChildNodes)
					{
						//Find a script with the specified key
						var scriptMatch = flatList.Where(x => x.Value.Contains(n.InnerText)).ToList();
						foreach (var script in scriptMatch)
						{
							//if the script is found move it to the top of the list
							retval.Add(script);

							//remove this item from the unordered list
							flatList.Remove(script);
						}
					}

					//Now that we have ordered the scripts and removed the originals now prepend the ordered list to the top of the scripts list
					retval.AddRange(flatList);
				}
				catch (Exception ex)
				{
					//Do Nothing
				}
			}
			else
			{
				retval = flatList;
			}
			return retval;
		}

		private void ReinstallUserDefinedScripts(List<KeyValuePair<string, string>> allScripts, List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, List<nHydrateDbObject> _databaseItems, List<nHydrateDbObject> _currentItems)
		{
			//Run all the scripts
			var newHashList = new Dictionary<nHydrateDbObject, string>();
			for (var ii = 0; ii < allScripts.Count; ii++)
			{
				var scriptItem = allScripts[ii];

				#region Load script hashes

				//var runScript = false;
				//var current = _databaseItems.FirstOrDefault(x => x.name.ToLower() == scriptItem.Key.ToLower());
				////if (current == null)
				////	current = _currentItems.FirstOrDefault(x => x.name.ToLower() == scriptItem.Key.ToLower());
				//var hashValue = string.Join("|", allScripts.Where(x => x.Key == scriptItem.Key).ToList()).CalculateMD5Hash();

				//if (current != null)
				//{
				//  if (current.Hash != hashValue)
				//  {
				//    runScript = true;
				//    current.ModifiedDate = DateTime.Now;
				//    _currentItems.RemoveAll(x => x.name.ToLower() == current.name.ToLower());
				//    _currentItems.Add(current);
				//  }

				//  if (!newHashList.ContainsKey(current))
				//    newHashList.Add(current, hashValue);
				//}
				//else
				//{
				//  runScript = true;
				//  current = new nHydrateDbObject()
				//  {
				//    name = scriptItem.Key,
				//    Hash = hashValue,
				//    ModelKey = new Guid(UpgradeInstaller.MODELKEY),
				//    type = "FILE",
				//  };
				//}

				////Add this item to list if it is new
				//if (!_currentItems.Any(x => x.name.ToLower() == scriptItem.Key.ToLower()))
				//  _currentItems.Add(current);

				#endregion

				//if (runScript)
				{
					SqlServers.ExecuteSQL(_connection, _transaction, scriptItem.Value, failedScripts, successOrderScripts);
				}

			}

			foreach (var k in newHashList.Keys)
				_currentItems.FirstOrDefault(x => x == k).Hash = newHashList[k];

		}

		private void ReinstallStoredProceduresUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, IEnumerable<string> skipSections)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation(".Stored_Procedures");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						//Skip Internal
						if (!ern.FullName.Contains(".Stored_Procedures.Internal"))
							SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, successOrderScripts, skipSections, _databaseItems, _currentItems);
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch { throw; }
		}

		private void ReinstallFunctionsUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, IEnumerable<string> skipSections)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation(".Functions");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						//Skip Internal
						if (!ern.FullName.Contains(".Functions.Internal"))
							SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, successOrderScripts, skipSections, _databaseItems, _currentItems);
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Function Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch { throw; }
		}

		private void ReinstallViewsUserDefined(List<KeyValuePair<Guid, string>> failedScripts, List<Guid> successOrderScripts, IEnumerable<string> skipSections)
		{
			try
			{
				var storedProcedures = this.GetResourceNameUnderLocation(".Views");
				foreach (EmbeddedResourceName ern in storedProcedures.Values)
				{
					try
					{
						//Skip Internal
						if (!ern.FullName.Contains(".Views.Internal"))
							SqlServers.RunEmbeddedFile(_connection, _transaction, ern.FullName, failedScripts, successOrderScripts, skipSections, _databaseItems, _currentItems);
					}
					catch
					{
						System.Windows.Forms.MessageBox.Show("Sp Fail: " + ern.FullName);
						throw;
					}
				}
			}
			catch { throw; }
		}

		#endregion

		private SortedDictionary<string, EmbeddedResourceName> GetResourceNameUnderLocation(string location)
		{
			var excludePathList = new List<string>();
			return GetResourceNameUnderLocation(location, excludePathList);
		}

		private SortedDictionary<string, EmbeddedResourceName> GetResourceNameUnderLocation(string location, List<string> excludePathList)
		{
			try
			{
				var retVal = new SortedDictionary<string, EmbeddedResourceName>();
				foreach (EmbeddedResourceName ern in _resourceNames)
				{
					if (ern.AsmLocation.StartsWith(location))
					{
						bool exclude = false;
						foreach (string path in excludePathList)
						{
							if (ern.AsmLocation.StartsWith(path))
								exclude = true;
						}

						if (!exclude) retVal.Add(ern.FullName, ern);
					}
				}
				return retVal;
			}
			catch { throw; }

		}

		private SortedDictionary<string, EmbeddedResourceName> GetResourceFileNameContains(string fileNamePart)
		{
			var retVal = new SortedDictionary<string, EmbeddedResourceName>();
			foreach (EmbeddedResourceName ern in _resourceNames)
			{
				if (ern.FileName.Contains(fileNamePart))
				{
					retVal.Add(ern.FileName, ern);
				}
			}
			return retVal;
		}

		#region UpgradeFileNameComparer class
		private class UpgradeFileNameComparer : IComparer<string>
		{
			#region IComparer<string> Members
			public int Compare(string x, string y)
			{
				return new GeneratedVersion(x).CompareTo(new GeneratedVersion(y));
			}
			#endregion
		}
		#endregion

		#region EmbeddedResourceName class
		private class EmbeddedResourceName
		{
			#region Members
			private string _fullName;
			private string _fileName;
			private string _fileExtension;
			private string _asmLocation;
			private string _asmNamespace;
			#endregion

			#region Constructors
			public EmbeddedResourceName(string fullName)
			{
				string[] splitName = fullName.Split('.');
				_fullName = fullName;
				_fileName = splitName[splitName.Length - 2];
				_fileExtension = splitName[splitName.Length - 1];
				_asmNamespace = DEFAULT_NAMESPACE;
				int namespaceCount = DEFAULT_NAMESPACE.Split('.').Length;
				_asmLocation = string.Empty;
				for (var ii = namespaceCount; ii < splitName.Length; ii++)
				{
					_asmLocation += "." + splitName[ii];
				}
				_asmLocation.Trim(new char[] { '.' });
			}
			#endregion

			#region Properties
			public string FullName
			{
				get { return _fullName; }
			}

			public string FileName
			{
				get { return _fileName; }
			}

			public string FileExtension
			{
				get { return _fileExtension; }
			}

			public string AsmLocation
			{
				get { return _asmLocation; }
			}

			public string AsmNamespace
			{
				get { return _asmNamespace; }
			}
			#endregion
		}
		#endregion

	}

	#region Version Class
	internal class GeneratedVersion : IComparable<GeneratedVersion>
	{
		#region member variables
		int _major = 0;
		int _minor = 0;
		int _revision = 0;
		int _build = 0;
		int _generated = 0;
		#endregion

		#region Constructors

		public GeneratedVersion()
		{
		}

		public GeneratedVersion(int major, int minor, int revision, int build)
			: this()
		{
			_major = major;
			_minor = minor;
			_revision = revision;
			_build = build;
		}

		public GeneratedVersion(int major, int minor, int revision, int build, int generated)
			: this(major, minor, revision, build)
		{
			_generated = generated;
		}

		public GeneratedVersion(GeneratedVersion version)
		{
			_build = version._build;
			_generated = version._generated;
			_major = version._major;
			_minor = version._minor;
			_revision = version._revision;
		}

		public GeneratedVersion(string[] versionSplit)
			: this()
		{
			if (versionSplit.Length > 0) int.TryParse(versionSplit[0], out _major);
			if (versionSplit.Length > 1) int.TryParse(versionSplit[1], out _minor);
			if (versionSplit.Length > 2) int.TryParse(versionSplit[2], out _revision);
			if (versionSplit.Length > 3) int.TryParse(versionSplit[3], out _build);
			if (versionSplit.Length > 4) int.TryParse(versionSplit[4], out _generated);
		}

		public static bool IsValid(string v)
		{
			if (string.IsNullOrEmpty(v))
				return false;

			var arr1 = v.Split('.');
			if (arr1.Length == 5)
			{
				foreach (var q in arr1)
				{
					int o;
					if (!int.TryParse(q, out o))
						return false;
				}
				return true;
			}
			return false;
		}

		public GeneratedVersion(string fileName)
		{
			try
			{
				if (fileName.Contains("_"))
				{
					var arr1 = fileName.Split('.');
					if (arr1.Length >= 1)
					{
						string[] versionSplit = null;

						if (arr1.Length == 1)
							versionSplit = arr1[0].Split('_');
						else
							versionSplit = arr1[arr1.Length - 2].Split('_');

						if (versionSplit.Length >= 5)
						{
							if (versionSplit.Length > 0) int.TryParse(versionSplit[0], out _major);
							if (versionSplit.Length > 1) int.TryParse(versionSplit[1], out _minor);
							if (versionSplit.Length > 2) int.TryParse(versionSplit[2], out _revision);
							if (versionSplit.Length > 3) int.TryParse(versionSplit[3], out _build);
							if (versionSplit.Length > 4) int.TryParse(versionSplit[4], out _generated);
							return;
						}
					}
					_major = -45;
				}
				else
				{
					var arr1 = fileName.Split('.');
					if (arr1.Length >= 5)
					{
						if (arr1.Length > 0) int.TryParse(arr1[0], out _major);
						if (arr1.Length > 1) int.TryParse(arr1[1], out _minor);
						if (arr1.Length > 2) int.TryParse(arr1[2], out _revision);
						if (arr1.Length > 3) int.TryParse(arr1[3], out _build);
						if (arr1.Length > 4) int.TryParse(arr1[4], out _generated);
					}
				}
			}
			catch
			{
			}
		}

		#endregion

		#region Properties

		public int Major
		{
			get { return _major; }
			set { _major = value; }
		}

		public int Minor
		{
			get { return _minor; }
			set { _minor = value; }
		}

		public int Revision
		{
			get { return _revision; }
			set { _revision = value; }
		}

		public int Build
		{
			get { return _build; }
			set { _build = value; }
		}

		public int Generated
		{
			get { return _generated; }
			set { _generated = value; }
		}

		#endregion

		#region IComparable<Version> Members
		public int CompareTo(GeneratedVersion other)
		{
			if (this.Major != other.Major)
				return this.Major.CompareTo(other.Major);
			else if (this.Minor != other.Minor)
				return this.Minor.CompareTo(other.Minor);
			else if (this.Revision != other.Revision)
				return this.Revision.CompareTo(other.Revision);
			else if (this.Build != other.Build)
				return this.Build.CompareTo(other.Build);
			else if (this.Generated != other.Generated)
				return this.Generated.CompareTo(other.Generated);
			else
				return 0;
		}
		#endregion

		#region Methods

		public override bool Equals(object obj)
		{
			if (!(obj is GeneratedVersion)) return false;
			var v = (GeneratedVersion)obj;
			return (v.Build == this.Build) &&
				(v.Generated == this.Generated) &&
				(v.Major == this.Major) &&
				(v.Minor == this.Minor) &&
				(v.Revision == this.Revision);
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public string ToString(string seperationChars)
		{
			string retval = this.Major + seperationChars + this.Minor + seperationChars + this.Revision + seperationChars + this.Build;
			if (this.Generated != 0) retval += seperationChars + this.Generated;
			return retval;
		}

		public override string ToString()
		{
			return this.ToString(".");
		}

		#endregion

		#region Operators

		public static bool operator <(GeneratedVersion r1, GeneratedVersion r2)
		{
			if ((object)r1 == null && (object)r2 == null) return false;
			if ((object)r1 == null ^ (object)r2 == null) return false;

			if (r1.Major < r2.Major) return true;
			if (r1.Major > r2.Major) return false;

			if (r1.Minor < r2.Minor) return true;
			if (r1.Minor > r2.Minor) return false;

			if (r1.Revision < r2.Revision) return true;
			if (r1.Revision > r2.Revision) return false;

			if (r1.Build < r2.Build) return true;
			if (r1.Build > r2.Build) return false;

			if (r1.Generated < r2.Generated) return true;
			if (r1.Generated > r2.Generated) return false;

			return false;
		}

		public static bool operator >(GeneratedVersion r1, GeneratedVersion r2)
		{
			if ((object)r1 == null && (object)r2 == null) return false;
			if ((object)r1 == null ^ (object)r2 == null) return false;

			if (r1.Major > r2.Major) return true;
			if (r1.Major < r2.Major) return false;

			if (r1.Minor > r2.Minor) return true;
			if (r1.Minor < r2.Minor) return false;

			if (r1.Revision > r2.Revision) return true;
			if (r1.Revision < r2.Revision) return false;

			if (r1.Build > r2.Build) return true;
			if (r1.Build < r2.Build) return false;

			if (r1.Generated > r2.Generated) return true;
			if (r1.Generated < r2.Generated) return false;

			return false;
		}

		public static bool operator ==(GeneratedVersion r1, GeneratedVersion r2)
		{
			if ((object)r1 == null && (object)r2 == null) return true;
			if ((object)r1 == null ^ (object)r2 == null) return false;
			if (r1 < r2) return false;
			if (r1 > r2) return false;
			return true;
		}

		public static bool operator !=(GeneratedVersion r1, GeneratedVersion r2)
		{
			if ((object)r1 == null && (object)r2 == null) return false;
			if ((object)r1 == null ^ (object)r2 == null) return true;
			if (r1 < r2) return true;
			if (r1 > r2) return true;
			return false;
		}

		#endregion

	}
	#endregion

	#region Extensions

	internal static class Extensions
	{
		public static string CalculateMD5Hash(this string input)
		{
			// step 1, calculate MD5 hash from input
			var md5 = System.Security.Cryptography.MD5.Create();
			var inputBytes = System.Text.Encoding.ASCII.GetBytes(input);
			var hash = md5.ComputeHash(inputBytes);

			// step 2, convert byte array to hex string
			var sb = new StringBuilder();
			for (var i = 0; i < hash.Length; i++)
			{
				sb.Append(hash[i].ToString("X2"));
			}
			return sb.ToString();
		}

		private static readonly string PasswordHash = "Pa@Sw0rd96d$";
		private static readonly string SaltKey = "8s$w@r1%";
		private static readonly string VIKey = "@2C1c3D4e5F6g7H8";

		public static string Encrypt(this string plainText)
		{
			try
			{
				var plainTextBytes = Encoding.UTF8.GetBytes(plainText);
				var keyBytes = new Rfc2898DeriveBytes(PasswordHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
				var symmetricKey = new RijndaelManaged() { Mode = CipherMode.CBC, Padding = PaddingMode.Zeros };
				var encryptor = symmetricKey.CreateEncryptor(keyBytes, Encoding.ASCII.GetBytes(VIKey));
				byte[] cipherTextBytes;
				using (var memoryStream = new MemoryStream())
				{
					using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
					{
						cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
						cryptoStream.FlushFinalBlock();
						cipherTextBytes = memoryStream.ToArray();
						cryptoStream.Close();
					}
					memoryStream.Close();
				}
				return Convert.ToBase64String(cipherTextBytes);
			}
			catch (Exception ex)
			{
				return null;
			}
		}

		public static string Decrypt(this string encryptedText)
		{
			try
			{
				var cipherTextBytes = Convert.FromBase64String(encryptedText);
				var keyBytes = new Rfc2898DeriveBytes(PasswordHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
				var symmetricKey = new RijndaelManaged() { Mode = CipherMode.CBC, Padding = PaddingMode.None };
				var decryptor = symmetricKey.CreateDecryptor(keyBytes, Encoding.ASCII.GetBytes(VIKey));
				var memoryStream = new MemoryStream(cipherTextBytes);
				var cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
				var plainTextBytes = new byte[cipherTextBytes.Length];
				var decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
				memoryStream.Close();
				cryptoStream.Close();
				return Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount).TrimEnd("\0".ToCharArray());
			}
			catch (Exception ex)
			{
				return null;
			}
		}

	}
	#endregion

}
#pragma warning restore 0168